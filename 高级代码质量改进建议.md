# 高级代码质量改进建议

## 🎯 基于Coze插件标准的改进

### 1. **类型定义标准化**

根据Coze插件的标准格式，建议创建标准的类型定义：

```python
# typings/connectivity_test/connectivity_test.py
from typing import TypedDict, Literal, Optional, List

class Input(TypedDict):
    """连通性测试插件输入参数"""
    timeout: Optional[int]  # 超时时间（秒），默认10
    test_type: Optional[Literal['basic', 'api', 'all']]  # 测试类型，默认'all'
    verbose: Optional[bool]  # 详细输出，默认True
    custom_urls: Optional[List[str]]  # 自定义测试URL列表
    retry_count: Optional[int]  # 重试次数，默认3

class TestResult(TypedDict):
    """单个测试结果"""
    url: str
    status_code: int | str
    response_time: float | str
    result: str
    success: bool
    error_details: Optional[str]

class Output(TypedDict):
    """连通性测试插件输出结果"""
    success: bool
    summary: str
    recommendation: str
    basic_test_results: List[TestResult]
    api_test_result: Optional[bool]
    accessible_count: int
    total_count: int
    test_time: str
    performance_metrics: Optional[dict]
    error: Optional[str]
    message: Optional[str]
```

### 2. **改进的插件主函数**

```python
from runtime import Args
from typings.connectivity_test.connectivity_test import Input, Output
from typing import Dict, Any
import traceback

def handler(args: Args[Input]) -> Output:
    """
    Coze连通性测试插件入口函数
    
    测试Coze.com API的连通性，包括基本连通性和Workflow API测试。
    支持自定义测试参数和详细的错误报告。
    
    Parameters:
    args: 插件参数
        args.input - 输入参数，包含测试配置
        args.logger - 日志记录器实例
    
    Returns:
    Output: 结构化的测试结果
    """
    start_time = datetime.now()
    
    try:
        # 参数验证和默认值设置
        config = TestConfig.from_input(args.input)
        
        # 创建增强版测试器
        tester = EnhancedCozeConnectivityTester(
            logger=args.logger,
            config=config
        )
        
        # 执行测试
        results = tester.run_comprehensive_test()
        
        # 添加性能指标
        execution_time = (datetime.now() - start_time).total_seconds()
        results['performance_metrics'] = {
            'execution_time_seconds': execution_time,
            'average_response_time': tester.get_average_response_time(),
            'success_rate': tester.get_success_rate()
        }
        
        return results
        
    except ValidationError as e:
        return _create_error_output(
            error=f"参数验证失败: {str(e)}",
            logger=args.logger
        )
    except Exception as e:
        return _create_error_output(
            error=f"测试执行失败: {str(e)}",
            logger=args.logger,
            include_traceback=True
        )

def _create_error_output(error: str, logger=None, include_traceback=False) -> Output:
    """创建错误输出"""
    error_details = error
    if include_traceback:
        error_details += f"\n\n详细错误信息:\n{traceback.format_exc()}"
    
    safe_log(logger, f"[ERROR] {error_details}")
    
    return {
        "success": False,
        "error": error,
        "message": error_details,
        "summary": "❌ 测试失败",
        "recommendation": "💡 请检查输入参数和网络连接",
        "basic_test_results": [],
        "api_test_result": None,
        "accessible_count": 0,
        "total_count": 0,
        "test_time": datetime.now().isoformat(),
        "performance_metrics": None
    }
```

### 3. **配置管理类**

```python
from pydantic import BaseModel, validator, Field
from typing import List, Literal, Optional

class TestConfig(BaseModel):
    """测试配置类，提供参数验证和默认值"""
    
    timeout: int = Field(default=10, ge=1, le=60, description="请求超时时间（秒）")
    test_type: Literal['basic', 'api', 'all'] = Field(default='all', description="测试类型")
    verbose: bool = Field(default=True, description="是否输出详细日志")
    custom_urls: Optional[List[str]] = Field(default=None, description="自定义测试URL列表")
    retry_count: int = Field(default=3, ge=0, le=10, description="重试次数")
    retry_delay: float = Field(default=1.0, ge=0.1, le=10.0, description="重试延迟（秒）")
    user_agent: str = Field(default="CozePlugin/2.0", description="User-Agent头")
    
    @validator('custom_urls')
    def validate_urls(cls, v):
        if v is not None:
            for url in v:
                if not url.startswith(('http://', 'https://')):
                    raise ValueError(f"无效的URL格式: {url}")
        return v
    
    @classmethod
    def from_input(cls, input_data: dict) -> 'TestConfig':
        """从输入数据创建配置"""
        return cls(**input_data)
    
    def get_test_urls(self) -> List[str]:
        """获取测试URL列表"""
        default_urls = [
            "https://api.coze.com/v1/chat",
            "https://api.coze.com/v1/workflows/chat",
            "https://api.coze.com/v1/workflows/run",
            "https://api.coze.com/open_api/v2/chat",
            "https://www.coze.com"
        ]
        
        if self.custom_urls:
            return self.custom_urls + default_urls
        return default_urls
```

### 4. **增强的测试器类**

```python
from dataclasses import dataclass, field
from contextlib import contextmanager
import time
from statistics import mean

@dataclass
class TestMetrics:
    """测试指标收集器"""
    response_times: List[float] = field(default_factory=list)
    success_count: int = 0
    failure_count: int = 0
    error_types: Dict[str, int] = field(default_factory=dict)
    
    def record_success(self, response_time: float):
        self.response_times.append(response_time)
        self.success_count += 1
    
    def record_failure(self, error_type: str):
        self.failure_count += 1
        self.error_types[error_type] = self.error_types.get(error_type, 0) + 1
    
    def get_average_response_time(self) -> float:
        return mean(self.response_times) if self.response_times else 0.0
    
    def get_success_rate(self) -> float:
        total = self.success_count + self.failure_count
        return self.success_count / total if total > 0 else 0.0

class EnhancedCozeConnectivityTester:
    """增强版Coze连通性测试器"""
    
    def __init__(self, logger=None, config: TestConfig = None):
        self.logger = logger
        self.config = config or TestConfig()
        self.metrics = TestMetrics()
        self.session = self._create_session()
    
    def _create_session(self) -> requests.Session:
        """创建配置好的请求会话"""
        session = requests.Session()
        session.headers.update({
            'User-Agent': self.config.user_agent,
            'Accept': 'application/json',
            'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8'
        })
        return session
    
    @contextmanager
    def _retry_context(self, operation_name: str):
        """重试上下文管理器"""
        for attempt in range(self.config.retry_count + 1):
            try:
                yield attempt
                break
            except (requests.exceptions.Timeout, 
                   requests.exceptions.ConnectionError) as e:
                if attempt == self.config.retry_count:
                    raise
                
                safe_log(self.logger, 
                        f"[WARNING] {operation_name} 第{attempt + 1}次尝试失败，{self.config.retry_delay}秒后重试")
                time.sleep(self.config.retry_delay * (2 ** attempt))  # 指数退避
    
    def test_single_url_with_retry(self, url: str) -> Dict[str, Any]:
        """带重试的单URL测试"""
        with self._retry_context(f"测试 {url}"):
            return self._test_single_url_internal(url)
    
    def _test_single_url_internal(self, url: str) -> Dict[str, Any]:
        """内部单URL测试方法"""
        start_time = time.time()
        
        try:
            response = self.session.get(url, timeout=self.config.timeout)
            response_time = time.time() - start_time
            
            result = self._analyze_response(response, response_time)
            
            if result['success']:
                self.metrics.record_success(response_time)
            else:
                self.metrics.record_failure(str(response.status_code))
            
            return result
            
        except requests.exceptions.Timeout:
            self.metrics.record_failure('TIMEOUT')
            return self._create_error_result(url, 'TIMEOUT', '❌ 请求超时')
        except requests.exceptions.ConnectionError:
            self.metrics.record_failure('CONNECTION_ERROR')
            return self._create_error_result(url, 'CONNECTION_ERROR', '❌ 连接错误')
        except Exception as e:
            self.metrics.record_failure('UNKNOWN_ERROR')
            return self._create_error_result(url, 'ERROR', f'❌ 未知错误: {str(e)}')
    
    def run_comprehensive_test(self) -> Output:
        """运行全面测试"""
        safe_log(self.logger, f"开始全面测试，配置: {self.config.dict()}")
        
        basic_results = []
        api_result = None
        
        # 基本连通性测试
        if self.config.test_type in ['basic', 'all']:
            urls = self.config.get_test_urls()
            for url in urls:
                safe_log(self.logger, f"测试URL: {url}")
                result = self.test_single_url_with_retry(url)
                basic_results.append(result)
                safe_log(self.logger, f"结果: {result['result']}")
        
        # API测试
        if self.config.test_type in ['api', 'all']:
            api_result = self.test_workflow_api_enhanced()
        
        # 生成总结
        summary, recommendation = self._generate_enhanced_summary(
            basic_results, api_result
        )
        
        return {
            "success": True,
            "summary": summary,
            "recommendation": recommendation,
            "basic_test_results": basic_results,
            "api_test_result": api_result,
            "accessible_count": sum(1 for r in basic_results if r.get('success', False)),
            "total_count": len(basic_results),
            "test_time": datetime.now().isoformat(),
            "performance_metrics": {
                "average_response_time": self.metrics.get_average_response_time(),
                "success_rate": self.metrics.get_success_rate(),
                "error_distribution": dict(self.metrics.error_types)
            }
        }
```

### 5. **安全的日志记录工具**

```python
def safe_log(logger, message: str, level: str = "info"):
    """安全的日志记录函数"""
    try:
        if logger:
            log_method = getattr(logger, level, None)
            if log_method and callable(log_method):
                log_method(message)
                return
        # 回退到print
        print(f"[{level.upper()}] {message}")
    except Exception:
        # 最后的回退
        print(f"[{level.upper()}] {message}")
```

### 6. **单元测试框架**

```python
import pytest
from unittest.mock import Mock, patch, MagicMock

class TestCozeConnectivityPlugin:
    """Coze连通性插件测试套件"""
    
    @pytest.fixture
    def mock_args(self):
        args = Mock()
        args.input = {
            'timeout': 5,
            'test_type': 'basic',
            'verbose': True
        }
        args.logger = Mock()
        return args
    
    @pytest.fixture
    def mock_successful_response(self):
        response = Mock()
        response.status_code = 200
        response.elapsed.total_seconds.return_value = 1.0
        return response
    
    def test_handler_success(self, mock_args, mock_successful_response):
        """测试成功场景"""
        with patch('requests.Session.get', return_value=mock_successful_response):
            result = handler(mock_args)
            
            assert result['success'] is True
            assert result['accessible_count'] > 0
            assert 'performance_metrics' in result
    
    def test_handler_with_invalid_input(self):
        """测试无效输入"""
        args = Mock()
        args.input = {'timeout': -1}  # 无效超时时间
        args.logger = Mock()
        
        result = handler(args)
        
        assert result['success'] is False
        assert '参数验证失败' in result['error']
    
    def test_safe_log_with_none_logger(self):
        """测试空logger的安全日志记录"""
        # 应该不抛出异常
        safe_log(None, "test message")
    
    @patch('requests.Session.get')
    def test_retry_mechanism(self, mock_get):
        """测试重试机制"""
        # 前两次失败，第三次成功
        mock_get.side_effect = [
            requests.exceptions.Timeout(),
            requests.exceptions.Timeout(),
            Mock(status_code=200, elapsed=Mock(total_seconds=lambda: 1.0))
        ]
        
        config = TestConfig(retry_count=3, retry_delay=0.1)
        tester = EnhancedCozeConnectivityTester(config=config)
        
        result = tester.test_single_url_with_retry("https://test.com")
        
        assert result['success'] is True
        assert mock_get.call_count == 3
```

### 7. **性能监控和分析**

```python
from dataclasses import dataclass
from typing import Dict, List
import json

@dataclass
class PerformanceReport:
    """性能报告"""
    total_tests: int
    successful_tests: int
    failed_tests: int
    average_response_time: float
    max_response_time: float
    min_response_time: float
    error_distribution: Dict[str, int]
    recommendations: List[str]
    
    def to_dict(self) -> dict:
        return {
            'total_tests': self.total_tests,
            'successful_tests': self.successful_tests,
            'failed_tests': self.failed_tests,
            'success_rate': self.successful_tests / self.total_tests if self.total_tests > 0 else 0,
            'average_response_time': self.average_response_time,
            'max_response_time': self.max_response_time,
            'min_response_time': self.min_response_time,
            'error_distribution': self.error_distribution,
            'recommendations': self.recommendations
        }
    
    def generate_recommendations(self) -> List[str]:
        """生成性能优化建议"""
        recommendations = []
        
        if self.average_response_time > 3.0:
            recommendations.append("⚠️ 平均响应时间较长，建议检查网络连接")
        
        if self.successful_tests / self.total_tests < 0.8:
            recommendations.append("❌ 成功率较低，建议检查API状态")
        
        if 'TIMEOUT' in self.error_distribution:
            recommendations.append("⏱️ 存在超时错误，建议增加超时时间")
        
        if not recommendations:
            recommendations.append("✅ 性能表现良好")
        
        return recommendations
```

## 📊 实施优先级

### 高优先级（立即实施）
1. ✅ 修复 `'NoneType' object is not callable` 错误
2. 🔄 实现标准化的类型定义
3. 🔄 添加参数验证
4. 🔄 改进错误处理

### 中优先级（短期实施）
1. 🔄 添加重试机制
2. 🔄 实现性能监控
3. 🔄 添加单元测试
4. 🔄 改进日志记录

### 低优先级（长期实施）
1. 🔄 异步支持
2. 🔄 缓存机制
3. 🔄 高级分析功能
4. 🔄 可视化报告

## 🎯 预期收益

通过实施这些改进，您的代码将获得：

- **🛡️ 更高的稳定性**: 通过完善的错误处理和重试机制
- **📈 更好的性能**: 通过性能监控和优化建议
- **🔧 更强的可维护性**: 通过标准化的代码结构和类型定义
- **🧪 更高的测试覆盖率**: 通过全面的单元测试
- **📊 更好的可观测性**: 通过详细的指标收集和报告

这些改进将使您的Coze插件更加专业、可靠和易于维护。