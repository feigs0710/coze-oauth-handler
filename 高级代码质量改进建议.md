# é«˜çº§ä»£ç è´¨é‡æ”¹è¿›å»ºè®®

## ğŸ¯ åŸºäºCozeæ’ä»¶æ ‡å‡†çš„æ”¹è¿›

### 1. **ç±»å‹å®šä¹‰æ ‡å‡†åŒ–**

æ ¹æ®Cozeæ’ä»¶çš„æ ‡å‡†æ ¼å¼ï¼Œå»ºè®®åˆ›å»ºæ ‡å‡†çš„ç±»å‹å®šä¹‰ï¼š

```python
# typings/connectivity_test/connectivity_test.py
from typing import TypedDict, Literal, Optional, List

class Input(TypedDict):
    """è¿é€šæ€§æµ‹è¯•æ’ä»¶è¾“å…¥å‚æ•°"""
    timeout: Optional[int]  # è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤10
    test_type: Optional[Literal['basic', 'api', 'all']]  # æµ‹è¯•ç±»å‹ï¼Œé»˜è®¤'all'
    verbose: Optional[bool]  # è¯¦ç»†è¾“å‡ºï¼Œé»˜è®¤True
    custom_urls: Optional[List[str]]  # è‡ªå®šä¹‰æµ‹è¯•URLåˆ—è¡¨
    retry_count: Optional[int]  # é‡è¯•æ¬¡æ•°ï¼Œé»˜è®¤3

class TestResult(TypedDict):
    """å•ä¸ªæµ‹è¯•ç»“æœ"""
    url: str
    status_code: int | str
    response_time: float | str
    result: str
    success: bool
    error_details: Optional[str]

class Output(TypedDict):
    """è¿é€šæ€§æµ‹è¯•æ’ä»¶è¾“å‡ºç»“æœ"""
    success: bool
    summary: str
    recommendation: str
    basic_test_results: List[TestResult]
    api_test_result: Optional[bool]
    accessible_count: int
    total_count: int
    test_time: str
    performance_metrics: Optional[dict]
    error: Optional[str]
    message: Optional[str]
```

### 2. **æ”¹è¿›çš„æ’ä»¶ä¸»å‡½æ•°**

```python
from runtime import Args
from typings.connectivity_test.connectivity_test import Input, Output
from typing import Dict, Any
import traceback

def handler(args: Args[Input]) -> Output:
    """
    Cozeè¿é€šæ€§æµ‹è¯•æ’ä»¶å…¥å£å‡½æ•°
    
    æµ‹è¯•Coze.com APIçš„è¿é€šæ€§ï¼ŒåŒ…æ‹¬åŸºæœ¬è¿é€šæ€§å’ŒWorkflow APIæµ‹è¯•ã€‚
    æ”¯æŒè‡ªå®šä¹‰æµ‹è¯•å‚æ•°å’Œè¯¦ç»†çš„é”™è¯¯æŠ¥å‘Šã€‚
    
    Parameters:
    args: æ’ä»¶å‚æ•°
        args.input - è¾“å…¥å‚æ•°ï¼ŒåŒ…å«æµ‹è¯•é…ç½®
        args.logger - æ—¥å¿—è®°å½•å™¨å®ä¾‹
    
    Returns:
    Output: ç»“æ„åŒ–çš„æµ‹è¯•ç»“æœ
    """
    start_time = datetime.now()
    
    try:
        # å‚æ•°éªŒè¯å’Œé»˜è®¤å€¼è®¾ç½®
        config = TestConfig.from_input(args.input)
        
        # åˆ›å»ºå¢å¼ºç‰ˆæµ‹è¯•å™¨
        tester = EnhancedCozeConnectivityTester(
            logger=args.logger,
            config=config
        )
        
        # æ‰§è¡Œæµ‹è¯•
        results = tester.run_comprehensive_test()
        
        # æ·»åŠ æ€§èƒ½æŒ‡æ ‡
        execution_time = (datetime.now() - start_time).total_seconds()
        results['performance_metrics'] = {
            'execution_time_seconds': execution_time,
            'average_response_time': tester.get_average_response_time(),
            'success_rate': tester.get_success_rate()
        }
        
        return results
        
    except ValidationError as e:
        return _create_error_output(
            error=f"å‚æ•°éªŒè¯å¤±è´¥: {str(e)}",
            logger=args.logger
        )
    except Exception as e:
        return _create_error_output(
            error=f"æµ‹è¯•æ‰§è¡Œå¤±è´¥: {str(e)}",
            logger=args.logger,
            include_traceback=True
        )

def _create_error_output(error: str, logger=None, include_traceback=False) -> Output:
    """åˆ›å»ºé”™è¯¯è¾“å‡º"""
    error_details = error
    if include_traceback:
        error_details += f"\n\nè¯¦ç»†é”™è¯¯ä¿¡æ¯:\n{traceback.format_exc()}"
    
    safe_log(logger, f"[ERROR] {error_details}")
    
    return {
        "success": False,
        "error": error,
        "message": error_details,
        "summary": "âŒ æµ‹è¯•å¤±è´¥",
        "recommendation": "ğŸ’¡ è¯·æ£€æŸ¥è¾“å…¥å‚æ•°å’Œç½‘ç»œè¿æ¥",
        "basic_test_results": [],
        "api_test_result": None,
        "accessible_count": 0,
        "total_count": 0,
        "test_time": datetime.now().isoformat(),
        "performance_metrics": None
    }
```

### 3. **é…ç½®ç®¡ç†ç±»**

```python
from pydantic import BaseModel, validator, Field
from typing import List, Literal, Optional

class TestConfig(BaseModel):
    """æµ‹è¯•é…ç½®ç±»ï¼Œæä¾›å‚æ•°éªŒè¯å’Œé»˜è®¤å€¼"""
    
    timeout: int = Field(default=10, ge=1, le=60, description="è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰")
    test_type: Literal['basic', 'api', 'all'] = Field(default='all', description="æµ‹è¯•ç±»å‹")
    verbose: bool = Field(default=True, description="æ˜¯å¦è¾“å‡ºè¯¦ç»†æ—¥å¿—")
    custom_urls: Optional[List[str]] = Field(default=None, description="è‡ªå®šä¹‰æµ‹è¯•URLåˆ—è¡¨")
    retry_count: int = Field(default=3, ge=0, le=10, description="é‡è¯•æ¬¡æ•°")
    retry_delay: float = Field(default=1.0, ge=0.1, le=10.0, description="é‡è¯•å»¶è¿Ÿï¼ˆç§’ï¼‰")
    user_agent: str = Field(default="CozePlugin/2.0", description="User-Agentå¤´")
    
    @validator('custom_urls')
    def validate_urls(cls, v):
        if v is not None:
            for url in v:
                if not url.startswith(('http://', 'https://')):
                    raise ValueError(f"æ— æ•ˆçš„URLæ ¼å¼: {url}")
        return v
    
    @classmethod
    def from_input(cls, input_data: dict) -> 'TestConfig':
        """ä»è¾“å…¥æ•°æ®åˆ›å»ºé…ç½®"""
        return cls(**input_data)
    
    def get_test_urls(self) -> List[str]:
        """è·å–æµ‹è¯•URLåˆ—è¡¨"""
        default_urls = [
            "https://api.coze.com/v1/chat",
            "https://api.coze.com/v1/workflows/chat",
            "https://api.coze.com/v1/workflows/run",
            "https://api.coze.com/open_api/v2/chat",
            "https://www.coze.com"
        ]
        
        if self.custom_urls:
            return self.custom_urls + default_urls
        return default_urls
```

### 4. **å¢å¼ºçš„æµ‹è¯•å™¨ç±»**

```python
from dataclasses import dataclass, field
from contextlib import contextmanager
import time
from statistics import mean

@dataclass
class TestMetrics:
    """æµ‹è¯•æŒ‡æ ‡æ”¶é›†å™¨"""
    response_times: List[float] = field(default_factory=list)
    success_count: int = 0
    failure_count: int = 0
    error_types: Dict[str, int] = field(default_factory=dict)
    
    def record_success(self, response_time: float):
        self.response_times.append(response_time)
        self.success_count += 1
    
    def record_failure(self, error_type: str):
        self.failure_count += 1
        self.error_types[error_type] = self.error_types.get(error_type, 0) + 1
    
    def get_average_response_time(self) -> float:
        return mean(self.response_times) if self.response_times else 0.0
    
    def get_success_rate(self) -> float:
        total = self.success_count + self.failure_count
        return self.success_count / total if total > 0 else 0.0

class EnhancedCozeConnectivityTester:
    """å¢å¼ºç‰ˆCozeè¿é€šæ€§æµ‹è¯•å™¨"""
    
    def __init__(self, logger=None, config: TestConfig = None):
        self.logger = logger
        self.config = config or TestConfig()
        self.metrics = TestMetrics()
        self.session = self._create_session()
    
    def _create_session(self) -> requests.Session:
        """åˆ›å»ºé…ç½®å¥½çš„è¯·æ±‚ä¼šè¯"""
        session = requests.Session()
        session.headers.update({
            'User-Agent': self.config.user_agent,
            'Accept': 'application/json',
            'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8'
        })
        return session
    
    @contextmanager
    def _retry_context(self, operation_name: str):
        """é‡è¯•ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        for attempt in range(self.config.retry_count + 1):
            try:
                yield attempt
                break
            except (requests.exceptions.Timeout, 
                   requests.exceptions.ConnectionError) as e:
                if attempt == self.config.retry_count:
                    raise
                
                safe_log(self.logger, 
                        f"[WARNING] {operation_name} ç¬¬{attempt + 1}æ¬¡å°è¯•å¤±è´¥ï¼Œ{self.config.retry_delay}ç§’åé‡è¯•")
                time.sleep(self.config.retry_delay * (2 ** attempt))  # æŒ‡æ•°é€€é¿
    
    def test_single_url_with_retry(self, url: str) -> Dict[str, Any]:
        """å¸¦é‡è¯•çš„å•URLæµ‹è¯•"""
        with self._retry_context(f"æµ‹è¯• {url}"):
            return self._test_single_url_internal(url)
    
    def _test_single_url_internal(self, url: str) -> Dict[str, Any]:
        """å†…éƒ¨å•URLæµ‹è¯•æ–¹æ³•"""
        start_time = time.time()
        
        try:
            response = self.session.get(url, timeout=self.config.timeout)
            response_time = time.time() - start_time
            
            result = self._analyze_response(response, response_time)
            
            if result['success']:
                self.metrics.record_success(response_time)
            else:
                self.metrics.record_failure(str(response.status_code))
            
            return result
            
        except requests.exceptions.Timeout:
            self.metrics.record_failure('TIMEOUT')
            return self._create_error_result(url, 'TIMEOUT', 'âŒ è¯·æ±‚è¶…æ—¶')
        except requests.exceptions.ConnectionError:
            self.metrics.record_failure('CONNECTION_ERROR')
            return self._create_error_result(url, 'CONNECTION_ERROR', 'âŒ è¿æ¥é”™è¯¯')
        except Exception as e:
            self.metrics.record_failure('UNKNOWN_ERROR')
            return self._create_error_result(url, 'ERROR', f'âŒ æœªçŸ¥é”™è¯¯: {str(e)}')
    
    def run_comprehensive_test(self) -> Output:
        """è¿è¡Œå…¨é¢æµ‹è¯•"""
        safe_log(self.logger, f"å¼€å§‹å…¨é¢æµ‹è¯•ï¼Œé…ç½®: {self.config.dict()}")
        
        basic_results = []
        api_result = None
        
        # åŸºæœ¬è¿é€šæ€§æµ‹è¯•
        if self.config.test_type in ['basic', 'all']:
            urls = self.config.get_test_urls()
            for url in urls:
                safe_log(self.logger, f"æµ‹è¯•URL: {url}")
                result = self.test_single_url_with_retry(url)
                basic_results.append(result)
                safe_log(self.logger, f"ç»“æœ: {result['result']}")
        
        # APIæµ‹è¯•
        if self.config.test_type in ['api', 'all']:
            api_result = self.test_workflow_api_enhanced()
        
        # ç”Ÿæˆæ€»ç»“
        summary, recommendation = self._generate_enhanced_summary(
            basic_results, api_result
        )
        
        return {
            "success": True,
            "summary": summary,
            "recommendation": recommendation,
            "basic_test_results": basic_results,
            "api_test_result": api_result,
            "accessible_count": sum(1 for r in basic_results if r.get('success', False)),
            "total_count": len(basic_results),
            "test_time": datetime.now().isoformat(),
            "performance_metrics": {
                "average_response_time": self.metrics.get_average_response_time(),
                "success_rate": self.metrics.get_success_rate(),
                "error_distribution": dict(self.metrics.error_types)
            }
        }
```

### 5. **å®‰å…¨çš„æ—¥å¿—è®°å½•å·¥å…·**

```python
def safe_log(logger, message: str, level: str = "info"):
    """å®‰å…¨çš„æ—¥å¿—è®°å½•å‡½æ•°"""
    try:
        if logger:
            log_method = getattr(logger, level, None)
            if log_method and callable(log_method):
                log_method(message)
                return
        # å›é€€åˆ°print
        print(f"[{level.upper()}] {message}")
    except Exception:
        # æœ€åçš„å›é€€
        print(f"[{level.upper()}] {message}")
```

### 6. **å•å…ƒæµ‹è¯•æ¡†æ¶**

```python
import pytest
from unittest.mock import Mock, patch, MagicMock

class TestCozeConnectivityPlugin:
    """Cozeè¿é€šæ€§æ’ä»¶æµ‹è¯•å¥—ä»¶"""
    
    @pytest.fixture
    def mock_args(self):
        args = Mock()
        args.input = {
            'timeout': 5,
            'test_type': 'basic',
            'verbose': True
        }
        args.logger = Mock()
        return args
    
    @pytest.fixture
    def mock_successful_response(self):
        response = Mock()
        response.status_code = 200
        response.elapsed.total_seconds.return_value = 1.0
        return response
    
    def test_handler_success(self, mock_args, mock_successful_response):
        """æµ‹è¯•æˆåŠŸåœºæ™¯"""
        with patch('requests.Session.get', return_value=mock_successful_response):
            result = handler(mock_args)
            
            assert result['success'] is True
            assert result['accessible_count'] > 0
            assert 'performance_metrics' in result
    
    def test_handler_with_invalid_input(self):
        """æµ‹è¯•æ— æ•ˆè¾“å…¥"""
        args = Mock()
        args.input = {'timeout': -1}  # æ— æ•ˆè¶…æ—¶æ—¶é—´
        args.logger = Mock()
        
        result = handler(args)
        
        assert result['success'] is False
        assert 'å‚æ•°éªŒè¯å¤±è´¥' in result['error']
    
    def test_safe_log_with_none_logger(self):
        """æµ‹è¯•ç©ºloggerçš„å®‰å…¨æ—¥å¿—è®°å½•"""
        # åº”è¯¥ä¸æŠ›å‡ºå¼‚å¸¸
        safe_log(None, "test message")
    
    @patch('requests.Session.get')
    def test_retry_mechanism(self, mock_get):
        """æµ‹è¯•é‡è¯•æœºåˆ¶"""
        # å‰ä¸¤æ¬¡å¤±è´¥ï¼Œç¬¬ä¸‰æ¬¡æˆåŠŸ
        mock_get.side_effect = [
            requests.exceptions.Timeout(),
            requests.exceptions.Timeout(),
            Mock(status_code=200, elapsed=Mock(total_seconds=lambda: 1.0))
        ]
        
        config = TestConfig(retry_count=3, retry_delay=0.1)
        tester = EnhancedCozeConnectivityTester(config=config)
        
        result = tester.test_single_url_with_retry("https://test.com")
        
        assert result['success'] is True
        assert mock_get.call_count == 3
```

### 7. **æ€§èƒ½ç›‘æ§å’Œåˆ†æ**

```python
from dataclasses import dataclass
from typing import Dict, List
import json

@dataclass
class PerformanceReport:
    """æ€§èƒ½æŠ¥å‘Š"""
    total_tests: int
    successful_tests: int
    failed_tests: int
    average_response_time: float
    max_response_time: float
    min_response_time: float
    error_distribution: Dict[str, int]
    recommendations: List[str]
    
    def to_dict(self) -> dict:
        return {
            'total_tests': self.total_tests,
            'successful_tests': self.successful_tests,
            'failed_tests': self.failed_tests,
            'success_rate': self.successful_tests / self.total_tests if self.total_tests > 0 else 0,
            'average_response_time': self.average_response_time,
            'max_response_time': self.max_response_time,
            'min_response_time': self.min_response_time,
            'error_distribution': self.error_distribution,
            'recommendations': self.recommendations
        }
    
    def generate_recommendations(self) -> List[str]:
        """ç”Ÿæˆæ€§èƒ½ä¼˜åŒ–å»ºè®®"""
        recommendations = []
        
        if self.average_response_time > 3.0:
            recommendations.append("âš ï¸ å¹³å‡å“åº”æ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®æ£€æŸ¥ç½‘ç»œè¿æ¥")
        
        if self.successful_tests / self.total_tests < 0.8:
            recommendations.append("âŒ æˆåŠŸç‡è¾ƒä½ï¼Œå»ºè®®æ£€æŸ¥APIçŠ¶æ€")
        
        if 'TIMEOUT' in self.error_distribution:
            recommendations.append("â±ï¸ å­˜åœ¨è¶…æ—¶é”™è¯¯ï¼Œå»ºè®®å¢åŠ è¶…æ—¶æ—¶é—´")
        
        if not recommendations:
            recommendations.append("âœ… æ€§èƒ½è¡¨ç°è‰¯å¥½")
        
        return recommendations
```

## ğŸ“Š å®æ–½ä¼˜å…ˆçº§

### é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³å®æ–½ï¼‰
1. âœ… ä¿®å¤ `'NoneType' object is not callable` é”™è¯¯
2. ğŸ”„ å®ç°æ ‡å‡†åŒ–çš„ç±»å‹å®šä¹‰
3. ğŸ”„ æ·»åŠ å‚æ•°éªŒè¯
4. ğŸ”„ æ”¹è¿›é”™è¯¯å¤„ç†

### ä¸­ä¼˜å…ˆçº§ï¼ˆçŸ­æœŸå®æ–½ï¼‰
1. ğŸ”„ æ·»åŠ é‡è¯•æœºåˆ¶
2. ğŸ”„ å®ç°æ€§èƒ½ç›‘æ§
3. ğŸ”„ æ·»åŠ å•å…ƒæµ‹è¯•
4. ğŸ”„ æ”¹è¿›æ—¥å¿—è®°å½•

### ä½ä¼˜å…ˆçº§ï¼ˆé•¿æœŸå®æ–½ï¼‰
1. ğŸ”„ å¼‚æ­¥æ”¯æŒ
2. ğŸ”„ ç¼“å­˜æœºåˆ¶
3. ğŸ”„ é«˜çº§åˆ†æåŠŸèƒ½
4. ğŸ”„ å¯è§†åŒ–æŠ¥å‘Š

## ğŸ¯ é¢„æœŸæ”¶ç›Š

é€šè¿‡å®æ–½è¿™äº›æ”¹è¿›ï¼Œæ‚¨çš„ä»£ç å°†è·å¾—ï¼š

- **ğŸ›¡ï¸ æ›´é«˜çš„ç¨³å®šæ€§**: é€šè¿‡å®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- **ğŸ“ˆ æ›´å¥½çš„æ€§èƒ½**: é€šè¿‡æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–å»ºè®®
- **ğŸ”§ æ›´å¼ºçš„å¯ç»´æŠ¤æ€§**: é€šè¿‡æ ‡å‡†åŒ–çš„ä»£ç ç»“æ„å’Œç±»å‹å®šä¹‰
- **ğŸ§ª æ›´é«˜çš„æµ‹è¯•è¦†ç›–ç‡**: é€šè¿‡å…¨é¢çš„å•å…ƒæµ‹è¯•
- **ğŸ“Š æ›´å¥½çš„å¯è§‚æµ‹æ€§**: é€šè¿‡è¯¦ç»†çš„æŒ‡æ ‡æ”¶é›†å’ŒæŠ¥å‘Š

è¿™äº›æ”¹è¿›å°†ä½¿æ‚¨çš„Cozeæ’ä»¶æ›´åŠ ä¸“ä¸šã€å¯é å’Œæ˜“äºç»´æŠ¤ã€‚