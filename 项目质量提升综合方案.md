# é¡¹ç›®è´¨é‡æå‡ç»¼åˆæ–¹æ¡ˆ

æœ¬æ–‡æ¡£æä¾›äº†Coze OAuthé›†æˆé¡¹ç›®çš„å…¨é¢è´¨é‡æå‡å»ºè®®ï¼Œæ¶µç›–ä»£ç è´¨é‡ã€æ¶æ„è®¾è®¡ã€å¼€å‘æµç¨‹å’Œç»´æŠ¤æ€§ç­‰å¤šä¸ªæ–¹é¢ã€‚

## ğŸ¯ æ€»ä½“ç›®æ ‡

- ğŸ”§ **æå‡ä»£ç è´¨é‡**ï¼šå¯è¯»æ€§ã€å¯ç»´æŠ¤æ€§ã€å¯æµ‹è¯•æ€§
- ğŸ—ï¸ **ä¼˜åŒ–æ¶æ„è®¾è®¡**ï¼šæ¨¡å—åŒ–ã€å¯æ‰©å±•ã€æ¾è€¦åˆ
- ğŸš€ **æ”¹è¿›å¼€å‘æµç¨‹**ï¼šè‡ªåŠ¨åŒ–ã€æ ‡å‡†åŒ–ã€é«˜æ•ˆç‡
- ğŸ“Š **å¢å¼ºç›‘æ§èƒ½åŠ›**ï¼šæ€§èƒ½ç›‘æ§ã€é”™è¯¯è¿½è¸ªã€æ—¥å¿—åˆ†æ
- ğŸ›¡ï¸ **åŠ å¼ºå®‰å…¨æ€§**ï¼šæ•°æ®ä¿æŠ¤ã€è®¿é—®æ§åˆ¶ã€æ¼æ´é˜²æŠ¤

## ğŸ“‹ å½“å‰é¡¹ç›®çŠ¶æ€è¯„ä¼°

### âœ… å·²å®ç°çš„ä¼˜ç§€å®è·µ

1. **å®Œæ•´çš„æ–‡æ¡£ä½“ç³»**ï¼š
   - è¯¦ç»†çš„ä½¿ç”¨æŒ‡å—å’Œé…ç½®è¯´æ˜
   - æ•…éšœæ’é™¤å’Œæœ€ä½³å®è·µæ–‡æ¡£
   - ä»£ç ç¤ºä¾‹å’ŒAPIæ–‡æ¡£

2. **æ¨¡å—åŒ–æ¶æ„**ï¼š
   - æ ¸å¿ƒOAuthé›†æˆæ¨¡å—
   - ç‹¬ç«‹çš„æµ‹è¯•å·¥å…·
   - é…ç½®ç®¡ç†å’Œä¾èµ–æ³¨å…¥

3. **æµ‹è¯•è¦†ç›–**ï¼š
   - å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
   - æ€§èƒ½æµ‹è¯•å’Œå¥å£®æ€§æµ‹è¯•
   - è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶

### ğŸ”„ éœ€è¦æ”¹è¿›çš„é¢†åŸŸ

1. **ä»£ç æ ‡å‡†åŒ–**ï¼šç»Ÿä¸€ç¼–ç è§„èŒƒå’Œä»£ç é£æ ¼
2. **é”™è¯¯å¤„ç†**ï¼šæ›´å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œæ¢å¤æœºåˆ¶
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜æœºåˆ¶å’Œè¿æ¥æ± ç®¡ç†
4. **å®‰å…¨åŠ å›º**ï¼šæ•æ„Ÿä¿¡æ¯ä¿æŠ¤å’Œè¾“å…¥éªŒè¯
5. **ç›‘æ§ä½“ç³»**ï¼šå®æ—¶ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶

## ğŸ—ï¸ æ¶æ„ä¼˜åŒ–æ–¹æ¡ˆ

### 1. åˆ†å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           è¡¨ç¤ºå±‚ (Presentation)      â”‚
â”‚  â”œâ”€â”€ CLIå·¥å…· (oauth_test_tool.py)   â”‚
â”‚  â”œâ”€â”€ Webç•Œé¢ (Vercelå›è°ƒé¡µé¢)        â”‚
â”‚  â””â”€â”€ APIæ¥å£ (coze_pluginæ¥å£)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           ä¸šåŠ¡é€»è¾‘å±‚ (Business)       â”‚
â”‚  â”œâ”€â”€ OAuthè®¤è¯æœåŠ¡                  â”‚
â”‚  â”œâ”€â”€ å·¥ä½œæµæ‰§è¡ŒæœåŠ¡                  â”‚
â”‚  â”œâ”€â”€ é…ç½®ç®¡ç†æœåŠ¡                   â”‚
â”‚  â””â”€â”€ ç›‘æ§æœåŠ¡                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           æ•°æ®è®¿é—®å±‚ (Data)          â”‚
â”‚  â”œâ”€â”€ HTTPå®¢æˆ·ç«¯                     â”‚
â”‚  â”œâ”€â”€ ç¼“å­˜ç®¡ç†                       â”‚
â”‚  â”œâ”€â”€ é…ç½®å­˜å‚¨                       â”‚
â”‚  â””â”€â”€ æ—¥å¿—å­˜å‚¨                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           åŸºç¡€è®¾æ–½å±‚ (Infrastructure) â”‚
â”‚  â”œâ”€â”€ ä¾èµ–æ³¨å…¥å®¹å™¨                   â”‚
â”‚  â”œâ”€â”€ é…ç½®ç®¡ç†å™¨                     â”‚
â”‚  â”œâ”€â”€ æ—¥å¿—ç³»ç»Ÿ                       â”‚
â”‚  â””â”€â”€ ç›‘æ§æ”¶é›†å™¨                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒæœåŠ¡é‡æ„

#### OAuthè®¤è¯æœåŠ¡

```python
# oauth_service.py
from abc import ABC, abstractmethod
from typing import Dict, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta

@dataclass
class TokenInfo:
    access_token: str
    refresh_token: Optional[str]
    expires_at: datetime
    token_type: str = "Bearer"
    scope: Optional[str] = None

class OAuthService(ABC):
    """OAuthè®¤è¯æœåŠ¡æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    async def get_authorization_url(self, state: str = None) -> str:
        """è·å–æˆæƒURL"""
        pass
    
    @abstractmethod
    async def exchange_code_for_token(self, code: str, state: str = None) -> TokenInfo:
        """äº¤æ¢æˆæƒç ä¸ºè®¿é—®ä»¤ç‰Œ"""
        pass
    
    @abstractmethod
    async def refresh_token(self, refresh_token: str) -> TokenInfo:
        """åˆ·æ–°è®¿é—®ä»¤ç‰Œ"""
        pass
    
    @abstractmethod
    async def revoke_token(self, token: str) -> bool:
        """æ’¤é”€ä»¤ç‰Œ"""
        pass

class CozeOAuthService(OAuthService):
    """Coze OAuthè®¤è¯æœåŠ¡å®ç°"""
    
    def __init__(self, config: CozeConfig, http_client: HttpClient, 
                 cache: CacheManager, metrics: MetricsCollector):
        self.config = config
        self.http_client = http_client
        self.cache = cache
        self.metrics = metrics
        self.logger = logging.getLogger(__name__)
    
    async def get_authorization_url(self, state: str = None) -> str:
        """è·å–æˆæƒURL"""
        with self.metrics.timer("oauth.get_authorization_url"):
            try:
                # ç”Ÿæˆstateå‚æ•°
                if not state:
                    state = self._generate_state()
                
                # æ„å»ºæˆæƒURL
                params = {
                    'client_id': self.config.oauth.client_id,
                    'redirect_uri': self.config.oauth.redirect_uri,
                    'response_type': 'code',
                    'scope': ' '.join(self.config.oauth.scopes),
                    'state': state
                }
                
                url = f"{self.config.oauth.auth_url}?{urlencode(params)}"
                
                # ç¼“å­˜stateç”¨äºéªŒè¯
                await self.cache.set(f"oauth_state:{state}", True, ttl=600)
                
                self.logger.info(f"Generated authorization URL for state: {state}")
                self.metrics.increment("oauth.authorization_url_generated")
                
                return url
                
            except Exception as e:
                self.logger.error(f"Failed to generate authorization URL: {e}")
                self.metrics.increment("oauth.authorization_url_error")
                raise
    
    async def exchange_code_for_token(self, code: str, state: str = None) -> TokenInfo:
        """äº¤æ¢æˆæƒç ä¸ºè®¿é—®ä»¤ç‰Œ"""
        with self.metrics.timer("oauth.exchange_code_for_token"):
            try:
                # éªŒè¯stateå‚æ•°
                if state:
                    is_valid = await self.cache.get(f"oauth_state:{state}")
                    if not is_valid:
                        raise ValueError("Invalid or expired state parameter")
                    await self.cache.delete(f"oauth_state:{state}")
                
                # å‡†å¤‡ä»¤ç‰Œè¯·æ±‚
                data = {
                    'grant_type': 'authorization_code',
                    'client_id': self.config.oauth.client_id,
                    'client_secret': self.config.oauth.client_secret,
                    'code': code,
                    'redirect_uri': self.config.oauth.redirect_uri
                }
                
                # å‘é€ä»¤ç‰Œè¯·æ±‚
                response = await self.http_client.post(
                    self.config.oauth.token_url,
                    data=data,
                    headers={'Content-Type': 'application/x-www-form-urlencoded'}
                )
                
                if response.status_code != 200:
                    raise Exception(f"Token exchange failed: {response.text}")
                
                token_data = response.json()
                
                # åˆ›å»ºTokenInfoå¯¹è±¡
                expires_in = token_data.get('expires_in', 3600)
                expires_at = datetime.utcnow() + timedelta(seconds=expires_in)
                
                token_info = TokenInfo(
                    access_token=token_data['access_token'],
                    refresh_token=token_data.get('refresh_token'),
                    expires_at=expires_at,
                    token_type=token_data.get('token_type', 'Bearer'),
                    scope=token_data.get('scope')
                )
                
                # ç¼“å­˜ä»¤ç‰Œä¿¡æ¯
                await self.cache.set(
                    f"oauth_token:{token_info.access_token[:10]}",
                    token_info,
                    ttl=expires_in - 60  # æå‰1åˆ†é’Ÿè¿‡æœŸ
                )
                
                self.logger.info("Successfully exchanged code for token")
                self.metrics.increment("oauth.token_exchange_success")
                
                return token_info
                
            except Exception as e:
                self.logger.error(f"Failed to exchange code for token: {e}")
                self.metrics.increment("oauth.token_exchange_error")
                raise
    
    def _generate_state(self) -> str:
        """ç”Ÿæˆéšæœºstateå‚æ•°"""
        import secrets
        return secrets.token_urlsafe(32)
```

#### å·¥ä½œæµæ‰§è¡ŒæœåŠ¡

```python
# workflow_service.py
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum

class WorkflowStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

@dataclass
class WorkflowExecution:
    execution_id: str
    workflow_id: str
    status: WorkflowStatus
    input_data: Dict[str, Any]
    output_data: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None
    created_at: datetime = None
    updated_at: datetime = None

class WorkflowService:
    """å·¥ä½œæµæ‰§è¡ŒæœåŠ¡"""
    
    def __init__(self, oauth_service: OAuthService, http_client: HttpClient,
                 cache: CacheManager, metrics: MetricsCollector):
        self.oauth_service = oauth_service
        self.http_client = http_client
        self.cache = cache
        self.metrics = metrics
        self.logger = logging.getLogger(__name__)
    
    async def execute_workflow(self, workflow_id: str, input_data: Dict[str, Any],
                             token: str) -> WorkflowExecution:
        """æ‰§è¡Œå·¥ä½œæµ"""
        execution_id = self._generate_execution_id()
        
        with self.metrics.timer("workflow.execute"):
            try:
                # åˆ›å»ºæ‰§è¡Œè®°å½•
                execution = WorkflowExecution(
                    execution_id=execution_id,
                    workflow_id=workflow_id,
                    status=WorkflowStatus.PENDING,
                    input_data=input_data,
                    created_at=datetime.utcnow()
                )
                
                # ç¼“å­˜æ‰§è¡ŒçŠ¶æ€
                await self.cache.set(f"workflow_execution:{execution_id}", execution)
                
                # æ›´æ–°çŠ¶æ€ä¸ºè¿è¡Œä¸­
                execution.status = WorkflowStatus.RUNNING
                execution.updated_at = datetime.utcnow()
                await self.cache.set(f"workflow_execution:{execution_id}", execution)
                
                # è°ƒç”¨Coze APIæ‰§è¡Œå·¥ä½œæµ
                response = await self.http_client.post(
                    f"/v1/workflows/{workflow_id}/execute",
                    json=input_data,
                    headers={
                        'Authorization': f'Bearer {token}',
                        'Content-Type': 'application/json'
                    }
                )
                
                if response.status_code == 200:
                    result = response.json()
                    execution.status = WorkflowStatus.COMPLETED
                    execution.output_data = result
                    self.metrics.increment("workflow.execute_success")
                else:
                    execution.status = WorkflowStatus.FAILED
                    execution.error_message = f"API Error: {response.status_code} - {response.text}"
                    self.metrics.increment("workflow.execute_error")
                
                execution.updated_at = datetime.utcnow()
                await self.cache.set(f"workflow_execution:{execution_id}", execution)
                
                self.logger.info(f"Workflow {workflow_id} execution {execution_id} completed with status: {execution.status}")
                
                return execution
                
            except Exception as e:
                execution.status = WorkflowStatus.FAILED
                execution.error_message = str(e)
                execution.updated_at = datetime.utcnow()
                await self.cache.set(f"workflow_execution:{execution_id}", execution)
                
                self.logger.error(f"Workflow execution failed: {e}")
                self.metrics.increment("workflow.execute_exception")
                raise
    
    async def get_execution_status(self, execution_id: str) -> Optional[WorkflowExecution]:
        """è·å–æ‰§è¡ŒçŠ¶æ€"""
        return await self.cache.get(f"workflow_execution:{execution_id}")
    
    async def list_executions(self, workflow_id: str = None, 
                            status: WorkflowStatus = None) -> List[WorkflowExecution]:
        """åˆ—å‡ºæ‰§è¡Œè®°å½•"""
        # å®ç°æ‰§è¡Œè®°å½•æŸ¥è¯¢é€»è¾‘
        pass
    
    def _generate_execution_id(self) -> str:
        """ç”Ÿæˆæ‰§è¡ŒID"""
        import uuid
        return str(uuid.uuid4())
```

## ğŸ”§ ä»£ç è´¨é‡æ”¹è¿›

### 1. ä»£ç è§„èŒƒå’Œé£æ ¼

#### é…ç½®æ–‡ä»¶ï¼š`.pre-commit-config.yaml`

```yaml
repos:
  - repo: https://github.com/psf/black
    rev: 23.3.0
    hooks:
      - id: black
        language_version: python3.9
        args: [--line-length=88]
  
  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
        args: [--profile=black]
  
  - repo: https://github.com/pycqa/flake8
    rev: 6.0.0
    hooks:
      - id: flake8
        args: [--max-line-length=88, --extend-ignore=E203,W503]
  
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.3.0
    hooks:
      - id: mypy
        additional_dependencies: [types-requests]
  
  - repo: https://github.com/pycqa/bandit
    rev: 1.7.5
    hooks:
      - id: bandit
        args: [-r, ., -f, json, -o, bandit-report.json]
```

#### é…ç½®æ–‡ä»¶ï¼š`pyproject.toml`

```toml
[tool.black]
line-length = 88
target-version = ['py39']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''

[tool.isort]
profile = "black"
line_length = 88
multi_line_output = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true

[tool.mypy]
python_version = "3.9"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true

[tool.pytest.ini_options]
minversion = "6.0"
addopts = "-ra -q --strict-markers --strict-config"
testpaths = ["tests"]
markers = [
    "slow: marks tests as slow (deselect with '-m "not slow"')",
    "integration: marks tests as integration tests",
    "unit: marks tests as unit tests",
]

[tool.coverage.run]
source = ["src"]
omit = [
    "*/tests/*",
    "*/test_*.py",
    "*/__pycache__/*",
]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "if self.debug:",
    "if settings.DEBUG",
    "raise AssertionError",
    "raise NotImplementedError",
    "if 0:",
    "if __name__ == .__main__.:",
    "class .*\bProtocol\):",
    "@(abc\.)?abstractmethod",
]
```

### 2. é”™è¯¯å¤„ç†å’Œæ—¥å¿—

#### è‡ªå®šä¹‰å¼‚å¸¸ç±»

```python
# exceptions.py
class CozeOAuthError(Exception):
    """Coze OAuthç›¸å…³é”™è¯¯åŸºç±»"""
    
    def __init__(self, message: str, error_code: str = None, 
                 details: Dict[str, Any] = None):
        super().__init__(message)
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        self.timestamp = datetime.utcnow()

class AuthenticationError(CozeOAuthError):
    """è®¤è¯é”™è¯¯"""
    pass

class AuthorizationError(CozeOAuthError):
    """æˆæƒé”™è¯¯"""
    pass

class TokenExpiredError(CozeOAuthError):
    """ä»¤ç‰Œè¿‡æœŸé”™è¯¯"""
    pass

class APIError(CozeOAuthError):
    """APIè°ƒç”¨é”™è¯¯"""
    
    def __init__(self, message: str, status_code: int = None, 
                 response_body: str = None, **kwargs):
        super().__init__(message, **kwargs)
        self.status_code = status_code
        self.response_body = response_body

class ConfigurationError(CozeOAuthError):
    """é…ç½®é”™è¯¯"""
    pass

class NetworkError(CozeOAuthError):
    """ç½‘ç»œé”™è¯¯"""
    pass
```

#### ç»“æ„åŒ–æ—¥å¿—é…ç½®

```python
# logging_config.py
import logging
import logging.config
from typing import Dict, Any
import json
from datetime import datetime

class StructuredFormatter(logging.Formatter):
    """ç»“æ„åŒ–æ—¥å¿—æ ¼å¼åŒ–å™¨"""
    
    def format(self, record: logging.LogRecord) -> str:
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno,
        }
        
        # æ·»åŠ å¼‚å¸¸ä¿¡æ¯
        if record.exc_info:
            log_entry['exception'] = self.formatException(record.exc_info)
        
        # æ·»åŠ è‡ªå®šä¹‰å­—æ®µ
        if hasattr(record, 'user_id'):
            log_entry['user_id'] = record.user_id
        if hasattr(record, 'request_id'):
            log_entry['request_id'] = record.request_id
        if hasattr(record, 'execution_id'):
            log_entry['execution_id'] = record.execution_id
        
        return json.dumps(log_entry, ensure_ascii=False)

def setup_logging(config: Dict[str, Any]) -> None:
    """è®¾ç½®æ—¥å¿—é…ç½®"""
    
    logging_config = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'structured': {
                '()': StructuredFormatter,
            },
            'simple': {
                'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            }
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'level': 'INFO',
                'formatter': 'simple',
                'stream': 'ext://sys.stdout'
            },
            'file': {
                'class': 'logging.handlers.RotatingFileHandler',
                'level': 'DEBUG',
                'formatter': 'structured',
                'filename': config.get('log_file', 'coze_oauth.log'),
                'maxBytes': 10485760,  # 10MB
                'backupCount': 5
            },
            'error_file': {
                'class': 'logging.handlers.RotatingFileHandler',
                'level': 'ERROR',
                'formatter': 'structured',
                'filename': config.get('error_log_file', 'coze_oauth_error.log'),
                'maxBytes': 10485760,  # 10MB
                'backupCount': 5
            }
        },
        'loggers': {
            'coze_oauth': {
                'level': config.get('log_level', 'INFO'),
                'handlers': ['console', 'file', 'error_file'],
                'propagate': False
            },
            'requests': {
                'level': 'WARNING',
                'handlers': ['file'],
                'propagate': False
            },
            'urllib3': {
                'level': 'WARNING',
                'handlers': ['file'],
                'propagate': False
            }
        },
        'root': {
            'level': 'WARNING',
            'handlers': ['console']
        }
    }
    
    logging.config.dictConfig(logging_config)
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. è¿æ¥æ± å’Œç¼“å­˜

```python
# http_client.py
import aiohttp
import asyncio
from typing import Optional, Dict, Any
from urllib.parse import urljoin

class AsyncHttpClient:
    """å¼‚æ­¥HTTPå®¢æˆ·ç«¯"""
    
    def __init__(self, base_url: str, timeout: int = 30, 
                 max_connections: int = 100, max_connections_per_host: int = 30):
        self.base_url = base_url
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        
        # è¿æ¥æ± é…ç½®
        connector = aiohttp.TCPConnector(
            limit=max_connections,
            limit_per_host=max_connections_per_host,
            ttl_dns_cache=300,
            use_dns_cache=True,
            keepalive_timeout=30,
            enable_cleanup_closed=True
        )
        
        self.session = aiohttp.ClientSession(
            connector=connector,
            timeout=self.timeout,
            headers={'User-Agent': 'CozeOAuth/1.0'}
        )
    
    async def get(self, url: str, params: Dict[str, Any] = None, 
                  headers: Dict[str, str] = None) -> aiohttp.ClientResponse:
        """GETè¯·æ±‚"""
        full_url = urljoin(self.base_url, url)
        async with self.session.get(full_url, params=params, headers=headers) as response:
            return response
    
    async def post(self, url: str, data: Any = None, json: Any = None,
                   headers: Dict[str, str] = None) -> aiohttp.ClientResponse:
        """POSTè¯·æ±‚"""
        full_url = urljoin(self.base_url, url)
        async with self.session.post(full_url, data=data, json=json, headers=headers) as response:
            return response
    
    async def close(self):
        """å…³é—­è¿æ¥"""
        await self.session.close()
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()
```

### 2. Redisç¼“å­˜å®ç°

```python
# cache_manager.py
import redis.asyncio as redis
import json
import pickle
from typing import Any, Optional, Union
from datetime import timedelta

class RedisCacheManager:
    """Redisç¼“å­˜ç®¡ç†å™¨"""
    
    def __init__(self, redis_url: str = "redis://localhost:6379", 
                 default_ttl: int = 3600, key_prefix: str = "coze_oauth:"):
        self.redis_url = redis_url
        self.default_ttl = default_ttl
        self.key_prefix = key_prefix
        self.redis_client = None
    
    async def connect(self):
        """è¿æ¥Redis"""
        self.redis_client = redis.from_url(
            self.redis_url,
            encoding="utf-8",
            decode_responses=False,
            max_connections=20
        )
    
    async def disconnect(self):
        """æ–­å¼€è¿æ¥"""
        if self.redis_client:
            await self.redis_client.close()
    
    def _make_key(self, key: str) -> str:
        """ç”Ÿæˆå®Œæ•´çš„ç¼“å­˜é”®"""
        return f"{self.key_prefix}{key}"
    
    async def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜å€¼"""
        try:
            full_key = self._make_key(key)
            data = await self.redis_client.get(full_key)
            if data is None:
                return None
            return pickle.loads(data)
        except Exception as e:
            logging.error(f"Cache get error for key {key}: {e}")
            return None
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """è®¾ç½®ç¼“å­˜å€¼"""
        try:
            full_key = self._make_key(key)
            data = pickle.dumps(value)
            ttl = ttl or self.default_ttl
            await self.redis_client.setex(full_key, ttl, data)
            return True
        except Exception as e:
            logging.error(f"Cache set error for key {key}: {e}")
            return False
    
    async def delete(self, key: str) -> bool:
        """åˆ é™¤ç¼“å­˜"""
        try:
            full_key = self._make_key(key)
            result = await self.redis_client.delete(full_key)
            return result > 0
        except Exception as e:
            logging.error(f"Cache delete error for key {key}: {e}")
            return False
    
    async def exists(self, key: str) -> bool:
        """æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨"""
        try:
            full_key = self._make_key(key)
            result = await self.redis_client.exists(full_key)
            return result > 0
        except Exception as e:
            logging.error(f"Cache exists error for key {key}: {e}")
            return False
    
    async def clear_pattern(self, pattern: str) -> int:
        """æ¸…é™¤åŒ¹é…æ¨¡å¼çš„é”®"""
        try:
            full_pattern = self._make_key(pattern)
            keys = await self.redis_client.keys(full_pattern)
            if keys:
                return await self.redis_client.delete(*keys)
            return 0
        except Exception as e:
            logging.error(f"Cache clear pattern error for pattern {pattern}: {e}")
            return 0
```

## ğŸ›¡ï¸ å®‰å…¨åŠ å›º

### 1. æ•æ„Ÿä¿¡æ¯ä¿æŠ¤

```python
# security.py
import os
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from typing import str, bytes

class SecretManager:
    """æ•æ„Ÿä¿¡æ¯ç®¡ç†å™¨"""
    
    def __init__(self, master_key: str = None):
        if master_key is None:
            master_key = os.environ.get('COZE_MASTER_KEY')
            if not master_key:
                raise ValueError("Master key not provided")
        
        self.fernet = self._create_fernet(master_key)
    
    def _create_fernet(self, master_key: str) -> Fernet:
        """åˆ›å»ºFernetåŠ å¯†å™¨"""
        # ä½¿ç”¨PBKDF2ä»ä¸»å¯†é’¥æ´¾ç”ŸåŠ å¯†å¯†é’¥
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=b'coze_oauth_salt',  # åœ¨ç”Ÿäº§ç¯å¢ƒä¸­åº”ä½¿ç”¨éšæœºç›
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(master_key.encode()))
        return Fernet(key)
    
    def encrypt(self, data: str) -> str:
        """åŠ å¯†æ•°æ®"""
        encrypted_data = self.fernet.encrypt(data.encode())
        return base64.urlsafe_b64encode(encrypted_data).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """è§£å¯†æ•°æ®"""
        encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode())
        decrypted_data = self.fernet.decrypt(encrypted_bytes)
        return decrypted_data.decode()
    
    def encrypt_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """åŠ å¯†é…ç½®ä¸­çš„æ•æ„Ÿå­—æ®µ"""
        sensitive_fields = ['client_secret', 'api_key', 'password', 'token']
        encrypted_config = config.copy()
        
        def encrypt_recursive(obj, path=""):
            if isinstance(obj, dict):
                for key, value in obj.items():
                    current_path = f"{path}.{key}" if path else key
                    if any(field in key.lower() for field in sensitive_fields):
                        if isinstance(value, str) and value:
                            obj[key] = self.encrypt(value)
                    elif isinstance(value, (dict, list)):
                        encrypt_recursive(value, current_path)
            elif isinstance(obj, list):
                for i, item in enumerate(obj):
                    encrypt_recursive(item, f"{path}[{i}]")
        
        encrypt_recursive(encrypted_config)
        return encrypted_config
    
    def decrypt_config(self, encrypted_config: Dict[str, Any]) -> Dict[str, Any]:
        """è§£å¯†é…ç½®ä¸­çš„æ•æ„Ÿå­—æ®µ"""
        sensitive_fields = ['client_secret', 'api_key', 'password', 'token']
        decrypted_config = encrypted_config.copy()
        
        def decrypt_recursive(obj, path=""):
            if isinstance(obj, dict):
                for key, value in obj.items():
                    current_path = f"{path}.{key}" if path else key
                    if any(field in key.lower() for field in sensitive_fields):
                        if isinstance(value, str) and value:
                            try:
                                obj[key] = self.decrypt(value)
                            except Exception:
                                # å¦‚æœè§£å¯†å¤±è´¥ï¼Œå¯èƒ½æ˜¯æ˜æ–‡ï¼Œä¿æŒåŸå€¼
                                pass
                    elif isinstance(value, (dict, list)):
                        decrypt_recursive(value, current_path)
            elif isinstance(obj, list):
                for i, item in enumerate(obj):
                    decrypt_recursive(item, f"{path}[{i}]")
        
        decrypt_recursive(decrypted_config)
        return decrypted_config
```

### 2. è¾“å…¥éªŒè¯å’Œæ¸…ç†

```python
# validators.py
import re
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse

class InputValidator:
    """è¾“å…¥éªŒè¯å™¨"""
    
    @staticmethod
    def validate_url(url: str) -> bool:
        """éªŒè¯URLæ ¼å¼"""
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except Exception:
            return False
    
    @staticmethod
    def validate_client_id(client_id: str) -> bool:
        """éªŒè¯å®¢æˆ·ç«¯IDæ ¼å¼"""
        if not client_id or not isinstance(client_id, str):
            return False
        # å®¢æˆ·ç«¯IDåº”è¯¥æ˜¯å­—æ¯æ•°å­—å­—ç¬¦ï¼Œé•¿åº¦åœ¨10-50ä¹‹é—´
        return re.match(r'^[a-zA-Z0-9_-]{10,50}$', client_id) is not None
    
    @staticmethod
    def validate_client_secret(client_secret: str) -> bool:
        """éªŒè¯å®¢æˆ·ç«¯å¯†é’¥æ ¼å¼"""
        if not client_secret or not isinstance(client_secret, str):
            return False
        # å®¢æˆ·ç«¯å¯†é’¥åº”è¯¥æ˜¯å­—æ¯æ•°å­—å­—ç¬¦ï¼Œé•¿åº¦åœ¨20-100ä¹‹é—´
        return re.match(r'^[a-zA-Z0-9_-]{20,100}$', client_secret) is not None
    
    @staticmethod
    def validate_authorization_code(code: str) -> bool:
        """éªŒè¯æˆæƒç æ ¼å¼"""
        if not code or not isinstance(code, str):
            return False
        # æˆæƒç åº”è¯¥æ˜¯å­—æ¯æ•°å­—å­—ç¬¦ï¼Œé•¿åº¦åœ¨10-200ä¹‹é—´
        return re.match(r'^[a-zA-Z0-9_-]{10,200}$', code) is not None
    
    @staticmethod
    def validate_state(state: str) -> bool:
        """éªŒè¯stateå‚æ•°æ ¼å¼"""
        if not state or not isinstance(state, str):
            return False
        # stateå‚æ•°åº”è¯¥æ˜¯å­—æ¯æ•°å­—å­—ç¬¦ï¼Œé•¿åº¦åœ¨10-50ä¹‹é—´
        return re.match(r'^[a-zA-Z0-9_-]{10,50}$', state) is not None
    
    @staticmethod
    def sanitize_string(value: str, max_length: int = 1000) -> str:
        """æ¸…ç†å­—ç¬¦ä¸²è¾“å…¥"""
        if not isinstance(value, str):
            return ""
        
        # ç§»é™¤æ§åˆ¶å­—ç¬¦
        sanitized = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', value)
        
        # é™åˆ¶é•¿åº¦
        if len(sanitized) > max_length:
            sanitized = sanitized[:max_length]
        
        return sanitized.strip()
    
    @staticmethod
    def validate_workflow_input(input_data: Dict[str, Any]) -> bool:
        """éªŒè¯å·¥ä½œæµè¾“å…¥æ•°æ®"""
        if not isinstance(input_data, dict):
            return False
        
        # æ£€æŸ¥æ•°æ®å¤§å°ï¼ˆé™åˆ¶ä¸º1MBï¼‰
        import json
        try:
            json_str = json.dumps(input_data)
            if len(json_str.encode('utf-8')) > 1024 * 1024:  # 1MB
                return False
        except Exception:
            return False
        
        # æ£€æŸ¥åµŒå¥—æ·±åº¦ï¼ˆé™åˆ¶ä¸º10å±‚ï¼‰
        def check_depth(obj, depth=0):
            if depth > 10:
                return False
            if isinstance(obj, dict):
                return all(check_depth(v, depth + 1) for v in obj.values())
            elif isinstance(obj, list):
                return all(check_depth(item, depth + 1) for item in obj)
            return True
        
        return check_depth(input_data)
```

## ğŸ“Š ç›‘æ§å’Œå‘Šè­¦

### 1. å¥åº·æ£€æŸ¥ç«¯ç‚¹

```python
# health_check.py
from typing import Dict, Any, List
from datetime import datetime, timedelta
from enum import Enum

class HealthStatus(Enum):
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"

class HealthChecker:
    """å¥åº·æ£€æŸ¥å™¨"""
    
    def __init__(self, oauth_service: OAuthService, cache: CacheManager,
                 metrics: MetricsCollector):
        self.oauth_service = oauth_service
        self.cache = cache
        self.metrics = metrics
    
    async def check_health(self) -> Dict[str, Any]:
        """æ‰§è¡Œå¥åº·æ£€æŸ¥"""
        checks = {
            'oauth_service': await self._check_oauth_service(),
            'cache': await self._check_cache(),
            'external_api': await self._check_external_api(),
            'metrics': await self._check_metrics(),
        }
        
        # è®¡ç®—æ€»ä½“çŠ¶æ€
        overall_status = self._calculate_overall_status(checks)
        
        return {
            'status': overall_status.value,
            'timestamp': datetime.utcnow().isoformat(),
            'checks': checks,
            'version': '1.0.0',
            'uptime': self._get_uptime()
        }
    
    async def _check_oauth_service(self) -> Dict[str, Any]:
        """æ£€æŸ¥OAuthæœåŠ¡"""
        try:
            # å°è¯•ç”ŸæˆæˆæƒURLï¼ˆä¸éœ€è¦å®é™…ç½‘ç»œè¯·æ±‚ï¼‰
            url = await self.oauth_service.get_authorization_url()
            return {
                'status': HealthStatus.HEALTHY.value,
                'message': 'OAuth service is operational',
                'response_time_ms': 0
            }
        except Exception as e:
            return {
                'status': HealthStatus.UNHEALTHY.value,
                'message': f'OAuth service error: {str(e)}',
                'response_time_ms': 0
            }
    
    async def _check_cache(self) -> Dict[str, Any]:
        """æ£€æŸ¥ç¼“å­˜æœåŠ¡"""
        try:
            start_time = datetime.utcnow()
            
            # æµ‹è¯•ç¼“å­˜è¯»å†™
            test_key = f"health_check_{int(start_time.timestamp())}"
            test_value = "health_check_value"
            
            await self.cache.set(test_key, test_value, ttl=60)
            retrieved_value = await self.cache.get(test_key)
            await self.cache.delete(test_key)
            
            response_time = (datetime.utcnow() - start_time).total_seconds() * 1000
            
            if retrieved_value == test_value:
                return {
                    'status': HealthStatus.HEALTHY.value,
                    'message': 'Cache is operational',
                    'response_time_ms': response_time
                }
            else:
                return {
                    'status': HealthStatus.UNHEALTHY.value,
                    'message': 'Cache read/write test failed',
                    'response_time_ms': response_time
                }
        except Exception as e:
            return {
                'status': HealthStatus.UNHEALTHY.value,
                'message': f'Cache error: {str(e)}',
                'response_time_ms': 0
            }
    
    async def _check_external_api(self) -> Dict[str, Any]:
        """æ£€æŸ¥å¤–éƒ¨APIè¿é€šæ€§"""
        try:
            start_time = datetime.utcnow()
            
            # ç®€å•çš„è¿é€šæ€§æµ‹è¯•ï¼ˆping coze.comï¼‰
            import aiohttp
            async with aiohttp.ClientSession() as session:
                async with session.get('https://www.coze.com/health', 
                                      timeout=aiohttp.ClientTimeout(total=5)) as response:
                    response_time = (datetime.utcnow() - start_time).total_seconds() * 1000
                    
                    if response.status == 200:
                        return {
                            'status': HealthStatus.HEALTHY.value,
                            'message': 'External API is reachable',
                            'response_time_ms': response_time
                        }
                    else:
                        return {
                            'status': HealthStatus.DEGRADED.value,
                            'message': f'External API returned status {response.status}',
                            'response_time_ms': response_time
                        }
        except Exception as e:
            return {
                'status': HealthStatus.UNHEALTHY.value,
                'message': f'External API error: {str(e)}',
                'response_time_ms': 0
            }
    
    async def _check_metrics(self) -> Dict[str, Any]:
        """æ£€æŸ¥ç›‘æ§æŒ‡æ ‡"""
        try:
            # æ£€æŸ¥æœ€è¿‘çš„é”™è¯¯ç‡
            error_rate = self.metrics.get_error_rate(timedelta(minutes=5))
            
            if error_rate < 0.05:  # 5%é”™è¯¯ç‡é˜ˆå€¼
                status = HealthStatus.HEALTHY
                message = f'Error rate is acceptable: {error_rate:.2%}'
            elif error_rate < 0.20:  # 20%é”™è¯¯ç‡é˜ˆå€¼
                status = HealthStatus.DEGRADED
                message = f'Error rate is elevated: {error_rate:.2%}'
            else:
                status = HealthStatus.UNHEALTHY
                message = f'Error rate is too high: {error_rate:.2%}'
            
            return {
                'status': status.value,
                'message': message,
                'error_rate': error_rate
            }
        except Exception as e:
            return {
                'status': HealthStatus.UNHEALTHY.value,
                'message': f'Metrics check error: {str(e)}',
                'error_rate': 0
            }
    
    def _calculate_overall_status(self, checks: Dict[str, Dict[str, Any]]) -> HealthStatus:
        """è®¡ç®—æ€»ä½“å¥åº·çŠ¶æ€"""
        statuses = [check['status'] for check in checks.values()]
        
        if all(status == HealthStatus.HEALTHY.value for status in statuses):
            return HealthStatus.HEALTHY
        elif any(status == HealthStatus.UNHEALTHY.value for status in statuses):
            return HealthStatus.UNHEALTHY
        else:
            return HealthStatus.DEGRADED
    
    def _get_uptime(self) -> str:
        """è·å–è¿è¡Œæ—¶é—´"""
        # è¿™é‡Œåº”è¯¥ä»åº”ç”¨å¯åŠ¨æ—¶é—´è®¡ç®—
        # ç®€åŒ–å®ç°ï¼Œè¿”å›å›ºå®šå€¼
        return "24h 30m 15s"
```

## ğŸ”„ CI/CD æµæ°´çº¿

### GitHub Actions é…ç½®

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.9, 3.10, 3.11]
    
    services:
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Lint with flake8
      run: |
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=88 --statistics
    
    - name: Type check with mypy
      run: |
        mypy src/
    
    - name: Security check with bandit
      run: |
        bandit -r src/ -f json -o bandit-report.json
    
    - name: Test with pytest
      run: |
        pytest --cov=src --cov-report=xml --cov-report=html
      env:
        REDIS_URL: redis://localhost:6379
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
    
    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results-${{ matrix.python-version }}
        path: |
          htmlcov/
          bandit-report.json
          pytest-report.xml

  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'

  deploy:
    needs: [test, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to production
      run: |
        echo "Deploying to production..."
        # è¿™é‡Œæ·»åŠ å®é™…çš„éƒ¨ç½²è„šæœ¬
```

## ğŸ“ˆ æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿

### Grafana ä»ªè¡¨æ¿é…ç½®

```json
{
  "dashboard": {
    "title": "Coze OAuth Integration Monitoring",
    "panels": [
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(coze_oauth_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ]
      },
      {
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(coze_oauth_errors_total[5m])",
            "legendFormat": "{{error_type}}"
          }
        ]
      },
      {
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(coze_oauth_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          },
          {
            "expr": "histogram_quantile(0.50, rate(coze_oauth_request_duration_seconds_bucket[5m]))",
            "legendFormat": "50th percentile"
          }
        ]
      },
      {
        "title": "Active Connections",
        "type": "singlestat",
        "targets": [
          {
            "expr": "coze_oauth_active_connections",
            "legendFormat": "Active Connections"
          }
        ]
      }
    ]
  }
}
```

## ğŸ“ å®æ–½è®¡åˆ’

### é˜¶æ®µ1ï¼šåŸºç¡€è®¾æ–½æ”¹è¿›ï¼ˆ1-2å‘¨ï¼‰

1. **ä»£ç è§„èŒƒåŒ–**ï¼š
   - é…ç½®pre-commit hooks
   - ç»Ÿä¸€ä»£ç æ ¼å¼åŒ–å’Œlinting
   - æ·»åŠ ç±»å‹æ³¨è§£

2. **é”™è¯¯å¤„ç†ä¼˜åŒ–**ï¼š
   - å®ç°è‡ªå®šä¹‰å¼‚å¸¸ç±»
   - æ·»åŠ ç»“æ„åŒ–æ—¥å¿—
   - æ”¹è¿›é”™è¯¯æ¢å¤æœºåˆ¶

3. **é…ç½®ç®¡ç†**ï¼š
   - å®ç°ç»Ÿä¸€é…ç½®ç®¡ç†
   - æ·»åŠ æ•æ„Ÿä¿¡æ¯åŠ å¯†
   - ç¯å¢ƒå˜é‡æ ‡å‡†åŒ–

### é˜¶æ®µ2ï¼šæ€§èƒ½å’Œå®‰å…¨ä¼˜åŒ–ï¼ˆ2-3å‘¨ï¼‰

1. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - å®ç°è¿æ¥æ± 
   - æ·»åŠ Redisç¼“å­˜
   - ä¼˜åŒ–å¼‚æ­¥å¤„ç†

2. **å®‰å…¨åŠ å›º**ï¼š
   - å®ç°è¾“å…¥éªŒè¯
   - æ·»åŠ å®‰å…¨å¤´
   - æ•æ„Ÿä¿¡æ¯ä¿æŠ¤

3. **ç›‘æ§ä½“ç³»**ï¼š
   - å®ç°æ€§èƒ½æŒ‡æ ‡æ”¶é›†
   - æ·»åŠ å¥åº·æ£€æŸ¥
   - é…ç½®å‘Šè­¦æœºåˆ¶

### é˜¶æ®µ3ï¼šé«˜çº§åŠŸèƒ½å’Œè‡ªåŠ¨åŒ–ï¼ˆ2-3å‘¨ï¼‰

1. **é«˜çº§åŠŸèƒ½**ï¼š
   - å®ç°ä»¤ç‰Œè‡ªåŠ¨åˆ·æ–°
   - æ·»åŠ é‡è¯•æœºåˆ¶
   - å®ç°ç†”æ–­å™¨æ¨¡å¼

2. **æµ‹è¯•å¢å¼º**ï¼š
   - å®Œå–„é›†æˆæµ‹è¯•
   - æ·»åŠ æ€§èƒ½æµ‹è¯•
   - å®ç°ç«¯åˆ°ç«¯æµ‹è¯•

3. **CI/CDä¼˜åŒ–**ï¼š
   - é…ç½®è‡ªåŠ¨åŒ–éƒ¨ç½²
   - æ·»åŠ å®‰å…¨æ‰«æ
   - å®ç°è“ç»¿éƒ¨ç½²

## ğŸ¯ æˆåŠŸæŒ‡æ ‡

### ä»£ç è´¨é‡æŒ‡æ ‡
- ä»£ç è¦†ç›–ç‡ > 90%
- é™æ€åˆ†ææ— ä¸¥é‡é—®é¢˜
- æŠ€æœ¯å€ºåŠ¡è¯„åˆ† < 5%

### æ€§èƒ½æŒ‡æ ‡
- APIå“åº”æ—¶é—´ < 200ms (P95)
- é”™è¯¯ç‡ < 1%
- å¯ç”¨æ€§ > 99.9%

### å®‰å…¨æŒ‡æ ‡
- æ— é«˜å±å®‰å…¨æ¼æ´
- æ•æ„Ÿä¿¡æ¯100%åŠ å¯†
- å®‰å…¨æ‰«æé€šè¿‡ç‡100%

### è¿ç»´æŒ‡æ ‡
- éƒ¨ç½²æ—¶é—´ < 5åˆ†é’Ÿ
- å›æ»šæ—¶é—´ < 2åˆ†é’Ÿ
- ç›‘æ§è¦†ç›–ç‡100%

---

é€šè¿‡å®æ–½è¿™ä¸ªç»¼åˆè´¨é‡æå‡æ–¹æ¡ˆï¼Œé¡¹ç›®å°†åœ¨ä»£ç è´¨é‡ã€æ€§èƒ½ã€å®‰å…¨æ€§å’Œå¯ç»´æŠ¤æ€§æ–¹é¢å¾—åˆ°å…¨é¢æå‡ï¼Œä¸ºé•¿æœŸç¨³å®šè¿è¡Œå¥ å®šåšå®åŸºç¡€ã€‚