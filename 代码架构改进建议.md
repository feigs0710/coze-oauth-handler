# 代码架构改进建议

基于当前项目结构分析，本文档提供针对性的架构改进建议，帮助提升代码的可维护性、可扩展性和可测试性。

## 📊 当前项目结构分析

### 现有文件结构
```
项目根目录/
├── 核心模块
│   ├── coze_oauth_integration.py     # OAuth集成主模块
│   ├── coze_connectivity_test_plugin.py  # 连通性测试插件
│   ├── oauth_test_tool.py           # OAuth测试工具
│   └── oauth_example.py             # OAuth示例代码
├── 架构增强模块
│   ├── config_manager.py            # 配置管理器
│   ├── dependency_injection.py      # 依赖注入容器
│   ├── metrics_collector.py         # 指标收集器
│   └── integration_test_framework.py # 集成测试框架
├── 测试文件
│   ├── final_test.py
│   ├── quick_test.py
│   ├── robust_test.py
│   └── test_coze_com_access.py
├── 部署相关
│   └── coze-oauth-handler/          # Vercel部署文件
└── 文档
    └── *.md                         # 各种指南文档
```

### 🔍 架构问题识别

1. **模块职责不清晰**：
   - 多个测试文件功能重叠
   - 核心业务逻辑分散在不同文件中
   - 缺乏明确的分层架构

2. **依赖关系复杂**：
   - 模块间耦合度较高
   - 缺乏统一的接口定义
   - 配置管理分散

3. **可扩展性限制**：
   - 硬编码的配置和常量
   - 缺乏插件化架构
   - 难以支持多种OAuth提供商

## 🏗️ 推荐架构重构方案

### 1. 分层架构设计

```
src/
├── presentation/           # 表示层
│   ├── cli/               # 命令行界面
│   │   ├── __init__.py
│   │   ├── oauth_cli.py   # OAuth CLI工具
│   │   └── test_cli.py    # 测试CLI工具
│   ├── web/               # Web界面
│   │   ├── __init__.py
│   │   ├── handlers.py    # Web处理器
│   │   └── templates/     # 模板文件
│   └── api/               # API接口
│       ├── __init__.py
│       ├── oauth_api.py   # OAuth API
│       └── health_api.py  # 健康检查API
├── application/            # 应用层
│   ├── __init__.py
│   ├── services/          # 应用服务
│   │   ├── __init__.py
│   │   ├── oauth_service.py
│   │   ├── workflow_service.py
│   │   └── notification_service.py
│   ├── use_cases/         # 用例
│   │   ├── __init__.py
│   │   ├── authenticate_user.py
│   │   ├── execute_workflow.py
│   │   └── refresh_token.py
│   └── dto/               # 数据传输对象
│       ├── __init__.py
│       ├── oauth_dto.py
│       └── workflow_dto.py
├── domain/                 # 领域层
│   ├── __init__.py
│   ├── entities/          # 实体
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── token.py
│   │   └── workflow.py
│   ├── repositories/      # 仓储接口
│   │   ├── __init__.py
│   │   ├── token_repository.py
│   │   └── user_repository.py
│   ├── services/          # 领域服务
│   │   ├── __init__.py
│   │   ├── token_validator.py
│   │   └── workflow_executor.py
│   └── events/            # 领域事件
│       ├── __init__.py
│       ├── token_refreshed.py
│       └── workflow_completed.py
├── infrastructure/         # 基础设施层
│   ├── __init__.py
│   ├── repositories/      # 仓储实现
│   │   ├── __init__.py
│   │   ├── memory_token_repository.py
│   │   ├── redis_token_repository.py
│   │   └── file_user_repository.py
│   ├── external/          # 外部服务
│   │   ├── __init__.py
│   │   ├── coze_api_client.py
│   │   ├── oauth_provider.py
│   │   └── notification_client.py
│   ├── persistence/       # 持久化
│   │   ├── __init__.py
│   │   ├── database.py
│   │   └── cache.py
│   └── monitoring/        # 监控
│       ├── __init__.py
│       ├── metrics.py
│       ├── logging.py
│       └── health_check.py
├── shared/                 # 共享模块
│   ├── __init__.py
│   ├── config/            # 配置
│   │   ├── __init__.py
│   │   ├── settings.py
│   │   └── environment.py
│   ├── exceptions/        # 异常
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── oauth_exceptions.py
│   │   └── api_exceptions.py
│   ├── utils/             # 工具
│   │   ├── __init__.py
│   │   ├── crypto.py
│   │   ├── validators.py
│   │   └── formatters.py
│   └── constants/         # 常量
│       ├── __init__.py
│       ├── oauth_constants.py
│       └── api_constants.py
└── tests/                  # 测试
    ├── __init__.py
    ├── unit/              # 单元测试
    ├── integration/       # 集成测试
    ├── e2e/              # 端到端测试
    └── fixtures/         # 测试夹具
```

### 2. 核心接口定义

#### OAuth提供商接口

```python
# src/domain/repositories/oauth_provider.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from ..entities.token import Token
from ..entities.user import User

class OAuthProvider(ABC):
    """OAuth提供商抽象接口"""
    
    @abstractmethod
    async def get_authorization_url(self, 
                                  state: str, 
                                  scopes: List[str]) -> str:
        """获取授权URL"""
        pass
    
    @abstractmethod
    async def exchange_code_for_token(self, 
                                    code: str, 
                                    state: str) -> Token:
        """交换授权码为令牌"""
        pass
    
    @abstractmethod
    async def refresh_token(self, refresh_token: str) -> Token:
        """刷新令牌"""
        pass
    
    @abstractmethod
    async def get_user_info(self, access_token: str) -> User:
        """获取用户信息"""
        pass
    
    @abstractmethod
    async def revoke_token(self, token: str) -> bool:
        """撤销令牌"""
        pass
```

#### 工作流执行器接口

```python
# src/domain/services/workflow_executor.py
from abc import ABC, abstractmethod
from typing import Dict, Any, List
from ..entities.workflow import Workflow, WorkflowExecution
from ..entities.token import Token

class WorkflowExecutor(ABC):
    """工作流执行器接口"""
    
    @abstractmethod
    async def execute(self, 
                     workflow: Workflow, 
                     input_data: Dict[str, Any],
                     token: Token) -> WorkflowExecution:
        """执行工作流"""
        pass
    
    @abstractmethod
    async def get_execution_status(self, 
                                 execution_id: str) -> WorkflowExecution:
        """获取执行状态"""
        pass
    
    @abstractmethod
    async def cancel_execution(self, execution_id: str) -> bool:
        """取消执行"""
        pass
    
    @abstractmethod
    async def list_executions(self, 
                             workflow_id: str = None,
                             status: str = None) -> List[WorkflowExecution]:
        """列出执行记录"""
        pass
```

### 3. 领域实体设计

#### Token实体

```python
# src/domain/entities/token.py
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Optional, List
from enum import Enum

class TokenType(Enum):
    ACCESS = "access"
    REFRESH = "refresh"
    ID = "id"

class TokenStatus(Enum):
    ACTIVE = "active"
    EXPIRED = "expired"
    REVOKED = "revoked"

@dataclass
class Token:
    """令牌实体"""
    value: str
    token_type: TokenType
    expires_at: datetime
    scopes: List[str]
    user_id: Optional[str] = None
    refresh_token: Optional[str] = None
    created_at: datetime = None
    updated_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.utcnow()
        if self.updated_at is None:
            self.updated_at = self.created_at
    
    @property
    def is_expired(self) -> bool:
        """检查令牌是否过期"""
        return datetime.utcnow() >= self.expires_at
    
    @property
    def expires_in_seconds(self) -> int:
        """获取令牌剩余有效时间（秒）"""
        if self.is_expired:
            return 0
        return int((self.expires_at - datetime.utcnow()).total_seconds())
    
    @property
    def status(self) -> TokenStatus:
        """获取令牌状态"""
        if self.is_expired:
            return TokenStatus.EXPIRED
        return TokenStatus.ACTIVE
    
    def extend_expiry(self, seconds: int) -> None:
        """延长令牌有效期"""
        self.expires_at += timedelta(seconds=seconds)
        self.updated_at = datetime.utcnow()
    
    def has_scope(self, scope: str) -> bool:
        """检查是否具有指定权限范围"""
        return scope in self.scopes
    
    def has_any_scope(self, scopes: List[str]) -> bool:
        """检查是否具有任一权限范围"""
        return any(scope in self.scopes for scope in scopes)
    
    def has_all_scopes(self, scopes: List[str]) -> bool:
        """检查是否具有所有权限范围"""
        return all(scope in self.scopes for scope in scopes)
```

#### Workflow实体

```python
# src/domain/entities/workflow.py
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, Any, List, Optional
from enum import Enum
import uuid

class WorkflowStatus(Enum):
    DRAFT = "draft"
    ACTIVE = "active"
    INACTIVE = "inactive"
    DEPRECATED = "deprecated"

class ExecutionStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    TIMEOUT = "timeout"

@dataclass
class WorkflowStep:
    """工作流步骤"""
    id: str
    name: str
    type: str
    config: Dict[str, Any]
    dependencies: List[str] = field(default_factory=list)
    timeout_seconds: int = 300
    retry_count: int = 0
    
@dataclass
class Workflow:
    """工作流实体"""
    id: str
    name: str
    description: str
    steps: List[WorkflowStep]
    status: WorkflowStatus = WorkflowStatus.DRAFT
    version: str = "1.0.0"
    created_by: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def add_step(self, step: WorkflowStep) -> None:
        """添加工作流步骤"""
        self.steps.append(step)
        self.updated_at = datetime.utcnow()
    
    def remove_step(self, step_id: str) -> bool:
        """移除工作流步骤"""
        for i, step in enumerate(self.steps):
            if step.id == step_id:
                del self.steps[i]
                self.updated_at = datetime.utcnow()
                return True
        return False
    
    def get_step(self, step_id: str) -> Optional[WorkflowStep]:
        """获取指定步骤"""
        for step in self.steps:
            if step.id == step_id:
                return step
        return None
    
    def validate(self) -> List[str]:
        """验证工作流配置"""
        errors = []
        
        if not self.name.strip():
            errors.append("Workflow name cannot be empty")
        
        if not self.steps:
            errors.append("Workflow must have at least one step")
        
        # 检查步骤ID唯一性
        step_ids = [step.id for step in self.steps]
        if len(step_ids) != len(set(step_ids)):
            errors.append("Step IDs must be unique")
        
        # 检查依赖关系
        for step in self.steps:
            for dep in step.dependencies:
                if dep not in step_ids:
                    errors.append(f"Step {step.id} depends on non-existent step {dep}")
        
        return errors
    
    def is_valid(self) -> bool:
        """检查工作流是否有效"""
        return len(self.validate()) == 0

@dataclass
class WorkflowExecution:
    """工作流执行实体"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    workflow_id: str = ""
    status: ExecutionStatus = ExecutionStatus.PENDING
    input_data: Dict[str, Any] = field(default_factory=dict)
    output_data: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    step_results: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def start(self) -> None:
        """开始执行"""
        self.status = ExecutionStatus.RUNNING
        self.started_at = datetime.utcnow()
    
    def complete(self, output_data: Dict[str, Any]) -> None:
        """完成执行"""
        self.status = ExecutionStatus.COMPLETED
        self.output_data = output_data
        self.completed_at = datetime.utcnow()
    
    def fail(self, error_message: str) -> None:
        """执行失败"""
        self.status = ExecutionStatus.FAILED
        self.error_message = error_message
        self.completed_at = datetime.utcnow()
    
    def cancel(self) -> None:
        """取消执行"""
        self.status = ExecutionStatus.CANCELLED
        self.completed_at = datetime.utcnow()
    
    @property
    def duration(self) -> Optional[timedelta]:
        """获取执行时长"""
        if self.started_at and self.completed_at:
            return self.completed_at - self.started_at
        return None
    
    @property
    def is_running(self) -> bool:
        """检查是否正在运行"""
        return self.status == ExecutionStatus.RUNNING
    
    @property
    def is_completed(self) -> bool:
        """检查是否已完成"""
        return self.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED, ExecutionStatus.CANCELLED]
```

### 4. 应用服务层

#### OAuth应用服务

```python
# src/application/services/oauth_service.py
from typing import Dict, Any, Optional
from datetime import datetime, timedelta

from ...domain.entities.token import Token, TokenType
from ...domain.entities.user import User
from ...domain.repositories.oauth_provider import OAuthProvider
from ...domain.repositories.token_repository import TokenRepository
from ...shared.exceptions.oauth_exceptions import (
    InvalidAuthorizationCodeError,
    TokenExpiredError,
    InvalidTokenError
)
from ...infrastructure.monitoring.metrics import MetricsCollector
from ...shared.config.settings import Settings

class OAuthApplicationService:
    """OAuth应用服务"""
    
    def __init__(self,
                 oauth_provider: OAuthProvider,
                 token_repository: TokenRepository,
                 metrics: MetricsCollector,
                 settings: Settings):
        self.oauth_provider = oauth_provider
        self.token_repository = token_repository
        self.metrics = metrics
        self.settings = settings
    
    async def initiate_authorization(self, 
                                   user_id: str,
                                   scopes: List[str] = None) -> Dict[str, str]:
        """发起OAuth授权"""
        try:
            # 生成state参数
            state = self._generate_state(user_id)
            
            # 使用配置的默认scopes或传入的scopes
            scopes = scopes or self.settings.oauth.default_scopes
            
            # 获取授权URL
            auth_url = await self.oauth_provider.get_authorization_url(state, scopes)
            
            # 记录授权发起事件
            self.metrics.increment('oauth.authorization_initiated')
            
            return {
                'authorization_url': auth_url,
                'state': state,
                'expires_in': 600  # state有效期10分钟
            }
            
        except Exception as e:
            self.metrics.increment('oauth.authorization_error')
            raise
    
    async def handle_authorization_callback(self, 
                                          code: str, 
                                          state: str) -> Token:
        """处理OAuth授权回调"""
        try:
            # 验证state参数
            user_id = self._validate_state(state)
            
            # 交换授权码为令牌
            token = await self.oauth_provider.exchange_code_for_token(code, state)
            token.user_id = user_id
            
            # 保存令牌
            await self.token_repository.save(token)
            
            # 记录成功事件
            self.metrics.increment('oauth.token_exchange_success')
            
            return token
            
        except Exception as e:
            self.metrics.increment('oauth.token_exchange_error')
            if isinstance(e, (InvalidAuthorizationCodeError, InvalidTokenError)):
                raise
            raise InvalidAuthorizationCodeError(f"Failed to exchange code: {str(e)}")
    
    async def refresh_access_token(self, refresh_token: str) -> Token:
        """刷新访问令牌"""
        try:
            # 验证refresh token
            stored_token = await self.token_repository.find_by_refresh_token(refresh_token)
            if not stored_token:
                raise InvalidTokenError("Invalid refresh token")
            
            # 刷新令牌
            new_token = await self.oauth_provider.refresh_token(refresh_token)
            new_token.user_id = stored_token.user_id
            
            # 保存新令牌
            await self.token_repository.save(new_token)
            
            # 删除旧令牌
            await self.token_repository.delete(stored_token.value)
            
            # 记录刷新事件
            self.metrics.increment('oauth.token_refresh_success')
            
            return new_token
            
        except Exception as e:
            self.metrics.increment('oauth.token_refresh_error')
            raise
    
    async def get_valid_token(self, user_id: str) -> Optional[Token]:
        """获取有效的访问令牌"""
        try:
            # 查找用户的令牌
            token = await self.token_repository.find_by_user_id(user_id)
            if not token:
                return None
            
            # 检查令牌是否过期
            if token.is_expired:
                # 尝试刷新令牌
                if token.refresh_token:
                    try:
                        return await self.refresh_access_token(token.refresh_token)
                    except Exception:
                        # 刷新失败，删除无效令牌
                        await self.token_repository.delete(token.value)
                        return None
                else:
                    # 没有refresh token，删除过期令牌
                    await self.token_repository.delete(token.value)
                    return None
            
            return token
            
        except Exception as e:
            self.metrics.increment('oauth.token_validation_error')
            raise
    
    async def revoke_token(self, token_value: str) -> bool:
        """撤销令牌"""
        try:
            # 从提供商撤销令牌
            success = await self.oauth_provider.revoke_token(token_value)
            
            # 从本地存储删除令牌
            await self.token_repository.delete(token_value)
            
            # 记录撤销事件
            self.metrics.increment('oauth.token_revoked')
            
            return success
            
        except Exception as e:
            self.metrics.increment('oauth.token_revoke_error')
            raise
    
    def _generate_state(self, user_id: str) -> str:
        """生成state参数"""
        import secrets
        import base64
        import json
        
        # 创建state payload
        payload = {
            'user_id': user_id,
            'timestamp': datetime.utcnow().isoformat(),
            'nonce': secrets.token_urlsafe(16)
        }
        
        # 编码state
        state_json = json.dumps(payload)
        state_bytes = state_json.encode('utf-8')
        return base64.urlsafe_b64encode(state_bytes).decode('utf-8')
    
    def _validate_state(self, state: str) -> str:
        """验证并解析state参数"""
        import base64
        import json
        from datetime import datetime, timedelta
        
        try:
            # 解码state
            state_bytes = base64.urlsafe_b64decode(state.encode('utf-8'))
            state_json = state_bytes.decode('utf-8')
            payload = json.loads(state_json)
            
            # 验证时间戳（10分钟有效期）
            timestamp = datetime.fromisoformat(payload['timestamp'])
            if datetime.utcnow() - timestamp > timedelta(minutes=10):
                raise InvalidTokenError("State parameter expired")
            
            return payload['user_id']
            
        except Exception as e:
            raise InvalidTokenError(f"Invalid state parameter: {str(e)}")
```

### 5. 基础设施层实现

#### Coze OAuth提供商实现

```python
# src/infrastructure/external/coze_oauth_provider.py
import aiohttp
from typing import Dict, Any, List
from urllib.parse import urlencode
from datetime import datetime, timedelta

from ...domain.repositories.oauth_provider import OAuthProvider
from ...domain.entities.token import Token, TokenType
from ...domain.entities.user import User
from ...shared.exceptions.oauth_exceptions import (
    OAuthProviderError,
    InvalidAuthorizationCodeError,
    TokenExpiredError
)
from ...shared.config.settings import Settings
from ...infrastructure.monitoring.metrics import MetricsCollector

class CozeOAuthProvider(OAuthProvider):
    """Coze OAuth提供商实现"""
    
    def __init__(self, 
                 settings: Settings, 
                 http_session: aiohttp.ClientSession,
                 metrics: MetricsCollector):
        self.settings = settings
        self.http_session = http_session
        self.metrics = metrics
        
        # OAuth端点配置
        self.auth_url = "https://www.coze.com/api/permission/oauth2/authorize"
        self.token_url = "https://www.coze.com/api/permission/oauth2/token"
        self.user_info_url = "https://www.coze.com/api/permission/oauth2/userinfo"
        self.revoke_url = "https://www.coze.com/api/permission/oauth2/revoke"
    
    async def get_authorization_url(self, 
                                  state: str, 
                                  scopes: List[str]) -> str:
        """获取授权URL"""
        params = {
            'client_id': self.settings.oauth.client_id,
            'redirect_uri': self.settings.oauth.redirect_uri,
            'response_type': 'code',
            'scope': ' '.join(scopes),
            'state': state
        }
        
        return f"{self.auth_url}?{urlencode(params)}"
    
    async def exchange_code_for_token(self, 
                                    code: str, 
                                    state: str) -> Token:
        """交换授权码为令牌"""
        data = {
            'grant_type': 'authorization_code',
            'client_id': self.settings.oauth.client_id,
            'client_secret': self.settings.oauth.client_secret,
            'code': code,
            'redirect_uri': self.settings.oauth.redirect_uri
        }
        
        try:
            async with self.http_session.post(
                self.token_url,
                data=data,
                headers={'Content-Type': 'application/x-www-form-urlencoded'}
            ) as response:
                
                if response.status != 200:
                    error_text = await response.text()
                    raise InvalidAuthorizationCodeError(
                        f"Token exchange failed: {response.status} - {error_text}"
                    )
                
                token_data = await response.json()
                
                # 创建Token实体
                expires_in = token_data.get('expires_in', 3600)
                expires_at = datetime.utcnow() + timedelta(seconds=expires_in)
                
                return Token(
                    value=token_data['access_token'],
                    token_type=TokenType.ACCESS,
                    expires_at=expires_at,
                    scopes=token_data.get('scope', '').split(),
                    refresh_token=token_data.get('refresh_token')
                )
                
        except aiohttp.ClientError as e:
            raise OAuthProviderError(f"Network error during token exchange: {str(e)}")
    
    async def refresh_token(self, refresh_token: str) -> Token:
        """刷新令牌"""
        data = {
            'grant_type': 'refresh_token',
            'client_id': self.settings.oauth.client_id,
            'client_secret': self.settings.oauth.client_secret,
            'refresh_token': refresh_token
        }
        
        try:
            async with self.http_session.post(
                self.token_url,
                data=data,
                headers={'Content-Type': 'application/x-www-form-urlencoded'}
            ) as response:
                
                if response.status != 200:
                    error_text = await response.text()
                    raise TokenExpiredError(
                        f"Token refresh failed: {response.status} - {error_text}"
                    )
                
                token_data = await response.json()
                
                # 创建新的Token实体
                expires_in = token_data.get('expires_in', 3600)
                expires_at = datetime.utcnow() + timedelta(seconds=expires_in)
                
                return Token(
                    value=token_data['access_token'],
                    token_type=TokenType.ACCESS,
                    expires_at=expires_at,
                    scopes=token_data.get('scope', '').split(),
                    refresh_token=token_data.get('refresh_token', refresh_token)
                )
                
        except aiohttp.ClientError as e:
            raise OAuthProviderError(f"Network error during token refresh: {str(e)}")
    
    async def get_user_info(self, access_token: str) -> User:
        """获取用户信息"""
        headers = {
            'Authorization': f'Bearer {access_token}',
            'Content-Type': 'application/json'
        }
        
        try:
            async with self.http_session.get(
                self.user_info_url,
                headers=headers
            ) as response:
                
                if response.status != 200:
                    error_text = await response.text()
                    raise OAuthProviderError(
                        f"Failed to get user info: {response.status} - {error_text}"
                    )
                
                user_data = await response.json()
                
                return User(
                    id=user_data['id'],
                    email=user_data.get('email'),
                    name=user_data.get('name'),
                    avatar_url=user_data.get('avatar_url'),
                    metadata=user_data
                )
                
        except aiohttp.ClientError as e:
            raise OAuthProviderError(f"Network error during user info retrieval: {str(e)}")
    
    async def revoke_token(self, token: str) -> bool:
        """撤销令牌"""
        data = {
            'client_id': self.settings.oauth.client_id,
            'client_secret': self.settings.oauth.client_secret,
            'token': token
        }
        
        try:
            async with self.http_session.post(
                self.revoke_url,
                data=data,
                headers={'Content-Type': 'application/x-www-form-urlencoded'}
            ) as response:
                
                return response.status == 200
                
        except aiohttp.ClientError:
            return False
```

## 🔄 迁移策略

### 阶段1：基础架构搭建（1-2周）

1. **创建新的目录结构**
2. **定义核心接口和实体**
3. **实现基础的依赖注入容器**
4. **迁移配置管理**

### 阶段2：核心功能迁移（2-3周）

1. **迁移OAuth功能到新架构**
2. **实现工作流执行服务**
3. **添加监控和日志**
4. **更新测试用例**

### 阶段3：优化和完善（1-2周）

1. **性能优化**
2. **错误处理完善**
3. **文档更新**
4. **部署脚本调整**

### 迁移脚本示例

```python
# migration/migrate_to_new_architecture.py
import os
import shutil
from pathlib import Path

def create_new_structure():
    """创建新的目录结构"""
    base_path = Path("src")
    
    directories = [
        "presentation/cli",
        "presentation/web", 
        "presentation/api",
        "application/services",
        "application/use_cases",
        "application/dto",
        "domain/entities",
        "domain/repositories",
        "domain/services",
        "domain/events",
        "infrastructure/repositories",
        "infrastructure/external",
        "infrastructure/persistence",
        "infrastructure/monitoring",
        "shared/config",
        "shared/exceptions",
        "shared/utils",
        "shared/constants",
        "tests/unit",
        "tests/integration",
        "tests/e2e",
        "tests/fixtures"
    ]
    
    for directory in directories:
        (base_path / directory).mkdir(parents=True, exist_ok=True)
        (base_path / directory / "__init__.py").touch()

def migrate_existing_files():
    """迁移现有文件"""
    migrations = {
        "coze_oauth_integration.py": "infrastructure/external/coze_api_client.py",
        "oauth_test_tool.py": "presentation/cli/oauth_cli.py",
        "config_manager.py": "shared/config/settings.py",
        "metrics_collector.py": "infrastructure/monitoring/metrics.py",
        "integration_test_framework.py": "tests/integration/framework.py"
    }
    
    for old_file, new_file in migrations.items():
        if os.path.exists(old_file):
            shutil.copy2(old_file, f"src/{new_file}")
            print(f"Migrated {old_file} -> src/{new_file}")

if __name__ == "__main__":
    create_new_structure()
    migrate_existing_files()
    print("Migration completed!")
```

## 📊 架构改进效果评估

### 改进前后对比

| 方面 | 改进前 | 改进后 |
|------|--------|--------|
| **模块耦合度** | 高 - 直接依赖具体实现 | 低 - 依赖抽象接口 |
| **可测试性** | 困难 - 难以mock依赖 | 容易 - 接口易于mock |
| **可扩展性** | 有限 - 硬编码实现 | 强 - 插件化架构 |
| **代码复用** | 低 - 功能重复实现 | 高 - 共享组件 |
| **维护成本** | 高 - 修改影响面大 | 低 - 职责分离清晰 |
| **部署复杂度** | 中等 - 单体部署 | 灵活 - 可分层部署 |

### 质量指标目标

- **代码覆盖率**: > 90%
- **圈复杂度**: < 10
- **模块耦合度**: < 0.3
- **接口稳定性**: > 95%
- **性能提升**: 响应时间减少30%
- **错误率降低**: < 1%

---

通过实施这个架构改进方案，项目将获得更好的可维护性、可扩展性和可测试性，为长期发展奠定坚实基础。